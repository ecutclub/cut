<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="microzz"><link rel="alternative" href="/atom.xml" title="ECUT Club" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title> - ECUT Club</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script><!-- Hotjar Tracking Code for ochukai.me --></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">ECUT Club</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head">  <time datetime="2017-04-19T00:24:13.632Z" class="post__time">April 19, 2017</time><h1 class="post__title"><a href="/2017/04/19/npm-scripts/"></a></h1><div class="post__main echo"><hr>
<p>title: npm scripts 使用指南<br>date: 2017-02-13 19:51:28<br>tags:</p>
<ul>
<li>npm</li>
<li>Nodejs</li>
<li>js</li>
<li>JavaScript</li>
</ul>
<hr>
<h1 id="npm-scripts-使用指南"><a href="#npm-scripts-使用指南" class="headerlink" title="npm scripts 使用指南"></a>npm scripts 使用指南</h1><blockquote>
<p>&nbsp;&nbsp;&nbsp;Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。<br>本文介绍如何使用 npm 脚本（npm scripts）。</p>
</blockquote>
<h2 id="一、什么是-npm-脚本？"><a href="#一、什么是-npm-脚本？" class="headerlink" title="一、什么是 npm 脚本？"></a>一、什么是 npm 脚本？</h2><p><code>npm</code> 允许在package.json文件里面，使用scripts字段定义脚本命令。</p>
<pre><code class="json">{
  // ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;node build.js&quot;
  }
}
</code></pre>
<p>上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，<code>build</code>命令对应的脚本是<code>node build.js</code>。<br>命令行下使用<code>npm run</code>命令，就可以执行这段脚本。</p>
<pre><code>$ npm run build
# 等同于执行
$ node build.js
</code></pre><p>这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。<br>项目的相关脚本，可以集中在一个地方。<br>不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行<code>npm run test</code>即可。<br>可以利用 npm 提供的很多辅助功能。<br>查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的<code>npm run</code>命令。</p>
<pre><code>$ npm run
</code></pre><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>npm 脚本的原理非常简单。每当执行<code>npm run</code>，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。<br>这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写<code>mocha test</code>就可以了。</p>
<pre><code class="json">&quot;test&quot;: &quot;mocha test&quot;
</code></pre>
<p>而不用写成下面这样。</p>
<pre><code class="json">&quot;test&quot;: &quot;./node_modules/.bin/mocha test&quot;
</code></pre>
<p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。<br>npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。</p>
<h2 id="三、通配符"><a href="#三、通配符" class="headerlink" title="三、通配符"></a>三、通配符</h2><p>由于 npm 脚本就是 Shell 脚本，因此可以使用 Shell 通配符。</p>
<pre><code class="json">&quot;lint&quot;: &quot;jshint *.js&quot;
&quot;lint&quot;: &quot;jshint **/*.js&quot;
</code></pre>
<p>上面代码中，<em>表示任意文件名，*</em>表示任意一层子目录。<br>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>
<pre><code class="json">&quot;test&quot;: &quot;tap test/\*.js&quot;
</code></pre>
<h2 id="四、传参"><a href="#四、传参" class="headerlink" title="四、传参"></a>四、传参</h2><p>向 npm 脚本传入参数，要使用–标明。</p>
<pre><code class="json">&quot;lint&quot;: &quot;jshint **.js&quot;
</code></pre>
<p>向上面的<code>npm run lint</code>命令传入参数，必须写成下面这样。</p>
<pre><code>$ npm run lint --  --reporter checkstyle &gt; checkstyle.xml
</code></pre><p>也可以在package.json里面再封装一个命令。</p>
<pre><code class="json">"lint": "jshint **.js",
"lint:checkstyle": "npm run lint -- --reporter checkstyle &gt; checkstyle.xml"
</code></pre>
<h2 id="五、执行顺序"><a href="#五、执行顺序" class="headerlink" title="五、执行顺序"></a>五、执行顺序</h2><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。<br>如果是并行执行（即同时的平行执行），可以使用&amp;符号。</p>
<pre><code>$ npm run script1.js &amp; npm run script2.js
</code></pre><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。</p>
<pre><code>$ npm run script1.js &amp;&amp; npm run script2.js
</code></pre><p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。</p>
<h2 id="六、默认值"><a href="#六、默认值" class="headerlink" title="六、默认值"></a>六、默认值</h2><p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。</p>
<pre><code class="json">&quot;start&quot;: &quot;node server.js&quot;，
&quot;install&quot;: &quot;node-gyp rebuild&quot;
</code></pre>
<p>上面代码中，<code>npm run start</code>的默认值是<code>node server.js</code>，前提是项目根目录下有server.js这个脚本；<code>npm run install</code>的默认值是<code>node-gyp rebuild</code>，前提是项目根目录下有binding.gyp文件。</p>
<h2 id="七、钩子"><a href="#七、钩子" class="headerlink" title="七、钩子"></a>七、钩子</h2><p>npm 脚本有pre和post两个钩子。举例来说，<code>build</code>脚本命令的钩子就是prebuild和postbuild。</p>
<pre><code class="json">&quot;prebuild&quot;: &quot;echo I run before the build script&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;,
&quot;postbuild&quot;: &quot;echo I run after the build script&quot;
</code></pre>
<p>用户执行<code>npm run build</code>的时候，会自动按照下面的顺序执行。</p>
<pre><code>npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild
</code></pre><p>因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p>
<pre><code class="json">"clean": "rimraf ./dist &amp;&amp; mkdir dist",
"prebuild": "npm run clean",
"build": "cross-env NODE_ENV=production webpack"
</code></pre>
<p>npm 默认提供下面这些钩子。</p>
<blockquote>
<p>prepublish，postpublish<br>preinstall，postinstall<br>preuninstall，postuninstall<br>preversion，postversion<br>pretest，posttest<br>prestop，poststop<br>prestart，poststart<br>prerestart，postrestart</p>
</blockquote>
<p>自定义的脚本命令也可以加上pre和post钩子。比如，<code>myscript</code>这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。<br>npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。</p>
<pre><code class="javascript"><span class="keyword">const</span> TARGET = process.env.npm_lifecycle_event;

<span class="keyword">if</span> (TARGET === <span class="string">'test'</span>) {
  <span class="built_in">console</span>.log(<span class="string">`Running the test task!`</span>);
}

<span class="keyword">if</span> (TARGET === <span class="string">'pretest'</span>) {
  <span class="built_in">console</span>.log(<span class="string">`Running the pretest task!`</span>);
}

<span class="keyword">if</span> (TARGET === <span class="string">'posttest'</span>) {
  <span class="built_in">console</span>.log(<span class="string">`Running the posttest task!`</span>);
}
</code></pre>
<p>注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在<code>npm install</code>（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。</p>
<h2 id="八、简写形式"><a href="#八、简写形式" class="headerlink" title="八、简写形式"></a>八、简写形式</h2><p>四个常用的 npm 脚本有简写形式。<br><code>npm start</code>是<code>npm run start</code><br><code>npm stop</code>是<code>npm run stop</code>的简写<br><code>npm test</code>是<code>npm run test</code>的简写<br><code>npm restart</code>是<code>npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start</code>的简写<br><code>npm start</code>、<code>npm stop</code>和<code>npm test</code>都比较好理解，而<code>npm restart</code>是一个复合命令，实际上会执行三个脚本命令：<code>stop</code>、<code>restart</code>、<code>start</code>。具体的执行顺序如下。<br><code>prerestart</code><br><code>prestop</code><br><code>stop</code><br><code>poststop</code><br><code>restart</code><br><code>prestart</code><br><code>start</code><br><code>poststart</code><br><code>postrestart</code></p>
<h2 id="九、变量"><a href="#九、变量" class="headerlink" title="九、变量"></a>九、变量</h2><p><code>npm</code> 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。<br>首先，通过npm<em>package</em>前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。</p>
<pre><code class="json">{
  <span class="attr">"name"</span>: <span class="string">"foo"</span>, 
  <span class="attr">"version"</span>: <span class="string">"1.2.5"</span>,
  <span class="attr">"scripts"</span>: {
    <span class="attr">"view"</span>: <span class="string">"node view.js"</span>
  }
}
</code></pre>
<p>那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。</p>
<pre><code class="js"><span class="comment">// view.js</span>
<span class="built_in">console</span>.log(process.env.npm_package_name); <span class="comment">// foo</span>
<span class="built_in">console</span>.log(process.env.npm_package_version); <span class="comment">// 1.2.5</span>
</code></pre>
<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到package.json的字段值。如果是 Bash 脚本，可以用\$npm_package_name和$npm_package_version取到这两个值。<br>npm<em>package</em>前缀也支持嵌套的package.json字段。</p>
<pre><code class="json">"repository": {
  "type": "git",
  "url": "xxx"
},
scripts: {
  "view": "echo $npm_package_repository_type"
}
</code></pre>
<p>上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。<br>下面是另外一个例子。</p>
<pre><code class="json">&quot;scripts&quot;: {
  &quot;install&quot;: &quot;foo.js&quot;
}
</code></pre>
<p>上面代码中，npm_package_scripts_install变量的值等于foo.js。<br>然后，npm 脚本还可以通过npm<em>config</em>前缀，拿到 npm 的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。</p>
<pre><code class="json">&quot;view&quot;: &quot;echo $npm_config_tag&quot;,
</code></pre>
<p>注意，package.json里面的config对象，可以被环境变量覆盖。</p>
<pre><code class="json">{ 
  <span class="attr">"name"</span> : <span class="string">"foo"</span>,
  <span class="attr">"config"</span> : { <span class="attr">"port"</span> : <span class="string">"8080"</span> },
  <span class="attr">"scripts"</span> : { <span class="attr">"start"</span> : <span class="string">"node server.js"</span> }
}
</code></pre>
<p>上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。</p>
<pre><code>$ npm config set foo:port 80
</code></pre><p>最后，env命令可以列出所有环境变量。</p>
<pre><code class="js"><span class="string">"env"</span>: <span class="string">"env"</span>
</code></pre>
<h2 id="十、常用脚本示例"><a href="#十、常用脚本示例" class="headerlink" title="十、常用脚本示例"></a>十、常用脚本示例</h2><pre><code class="json">// 删除目录
"clean": "rimraf dist/*",

// 本地搭建一个 HTTP 服务
"serve": "http-server -p 9090 dist/",

// 打开浏览器
"open:dev": "opener http://localhost:9090",

// 实时刷新
 "livereload": "live-reload --port 9091 dist/",

// 构建 HTML 文件
"build:html": "jade index.jade &gt; dist/index.html",

// 只要 CSS 文件有变动，就重新执行构建
"watch:css": "watch 'npm run build:css' assets/styles/",

// 只要 HTML 文件有变动，就重新执行构建
"watch:html": "watch 'npm run build:html' assets/html",

// 部署到 Amazon S3
"deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/",

// 构建 favicon
"build:favicon": "node scripts/favicon.js",
</code></pre>
</div></header></article><section class="reward"> <a href="#" class="btn-reward">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png"></div></section></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016-2017 microzz</div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/2017/04/19/module/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/2017/04/19/object/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>