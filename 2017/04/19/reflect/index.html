<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="microzz"><link rel="alternative" href="/atom.xml" title="ECUT Club" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title> - ECUT Club</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script><!-- Hotjar Tracking Code for ochukai.me --></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">ECUT Club</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head">  <time datetime="2017-04-19T00:24:13.710Z" class="post__time">April 19, 2017</time><h1 class="post__title"><a href="/2017/04/19/reflect/"></a></h1><div class="post__main echo"><hr>
<p>title: Reflect<br>date: 2017-01-11 08:25:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JS
- ES6
- Reflect
</code></pre><hr>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>
<p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>
<pre><code class="javascript"><span class="comment">// 老写法</span>
<span class="keyword">try</span> {
  <span class="built_in">Object</span>.defineProperty(target, property, attributes);
  <span class="comment">// success</span>
} <span class="keyword">catch</span> (e) {
  <span class="comment">// failure</span>
}

<span class="comment">// 新写法</span>
<span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) {
  <span class="comment">// success</span>
} <span class="keyword">else</span> {
  <span class="comment">// failure</span>
}
</code></pre>
<p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<pre><code class="javascript"><span class="comment">// 老写法</span>
<span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span>
</code></pre>
<p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<pre><code class="javascript"><span class="built_in">Proxy</span>(target, {
  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>{
    <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target,name, value, receiver);
    <span class="keyword">if</span> (success) {
      log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);
    }
    <span class="keyword">return</span> success;
  }
});
</code></pre>
<p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {
  get(target, name) {
    <span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);
  },
  deleteProperty(target, name) {
    <span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);
  },
  has(target, name) {
    <span class="built_in">console</span>.log(<span class="string">'has'</span> + name);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);
  }
});
</code></pre>
<p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p>
<pre><code class="javascript"><span class="comment">// 老写法</span>
<span class="built_in">Function</span>.prototype.apply.call(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span>
</code></pre>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Reflect</code>对象一共有13个静态方法。</p>
<ul>
<li>Reflect.apply(target,thisArg,args)</li>
<li>Reflect.construct(target,args)</li>
<li>Reflect.get(target,name,receiver)</li>
<li>Reflect.set(target,name,value,receiver)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.deleteProperty(target,name)</li>
<li>Reflect.has(target,name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p>
<h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  <span class="attr">bar</span>: <span class="number">2</span>,
  get baz() {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;
  },
}

<span class="built_in">Reflect</span>.get(myObject, <span class="string">'foo'</span>) <span class="comment">// 1</span>
<span class="built_in">Reflect</span>.get(myObject, <span class="string">'bar'</span>) <span class="comment">// 2</span>
<span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>) <span class="comment">// 3</span>
</code></pre>
<p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  <span class="attr">bar</span>: <span class="number">2</span>,
  get baz() {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;
  },
};

<span class="keyword">var</span> myReceiverObject = {
  <span class="attr">foo</span>: <span class="number">4</span>,
  <span class="attr">bar</span>: <span class="number">4</span>,
};

<span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>, myReceiverObject) <span class="comment">// 8</span>
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>
<pre><code class="javascript"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">'foo'</span>) <span class="comment">// 报错</span>
<span class="built_in">Reflect</span>.get(<span class="literal">false</span>, <span class="string">'foo'</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  set bar(value) {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;
  },
}

myObject.foo <span class="comment">// 1</span>

<span class="built_in">Reflect</span>.set(myObject, <span class="string">'foo'</span>, <span class="number">2</span>);
myObject.foo <span class="comment">// 2</span>

<span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">3</span>)
myObject.foo <span class="comment">// 3</span>
</code></pre>
<p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">4</span>,
  set bar(value) {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;
  },
};

<span class="keyword">var</span> myReceiverObject = {
  <span class="attr">foo</span>: <span class="number">0</span>,
};

<span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">1</span>, myReceiverObject);
myObject.foo <span class="comment">// 4</span>
myReceiverObject.foo <span class="comment">// 1</span>
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>
<pre><code class="javascript"><span class="built_in">Reflect</span>.set(<span class="number">1</span>, <span class="string">'foo'</span>, {}) <span class="comment">// 报错</span>
<span class="built_in">Reflect</span>.set(<span class="literal">false</span>, <span class="string">'foo'</span>, {}) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
};

<span class="comment">// 旧写法</span>
<span class="string">'foo'</span> <span class="keyword">in</span> myObject <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.has(myObject, <span class="string">'foo'</span>) <span class="comment">// true</span>
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.has</code>和<code>in</code>运算符都会报错。</p>
<h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObj = { <span class="attr">foo</span>: <span class="string">'bar'</span> };

<span class="comment">// 旧写法</span>
<span class="keyword">delete</span> myObj.foo;

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.deleteProperty(myObj, <span class="string">'foo'</span>);
</code></pre>
<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p>
<h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">name</span>) </span>{
  <span class="keyword">this</span>.name = name;
}

<span class="comment">// new 的写法</span>
<span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(<span class="string">'张三'</span>);

<span class="comment">// Reflect.construct 的写法</span>
<span class="keyword">const</span> instance = <span class="built_in">Reflect</span>.construct(Greeting, <span class="string">'张三'</span>);
</code></pre>
<h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.getPrototypeOf(myObj) === FancyThing.prototype;

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.getPrototypeOf(myObj) === FancyThing.prototype;
</code></pre>
<p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果第一个参数不是对象（包括<code>null</code>和<code>undefined</code>），<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// undefined</span>
<span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置对象的<code>__proto__</code>属性，对应<code>Object.setPrototypeOf(obj, newProto)</code>。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.setPrototypeOf(myObj, OtherThing.prototype);

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.setPrototypeOf(myObj, OtherThing.prototype);
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.setPrototypeOf</code>和<code>Object.setPrototypeOf</code>都会报错。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span>
<span class="built_in">Reflect</span>.setPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p>
<p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p>
<pre><code class="javascript"><span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];

<span class="comment">// 旧写法</span>
<span class="keyword">const</span> youngest = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, ages);
<span class="keyword">const</span> oldest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, ages);
<span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(youngest);

<span class="comment">// 新写法</span>
<span class="keyword">const</span> youngest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>, ages);
<span class="keyword">const</span> oldest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.max, <span class="built_in">Math</span>, ages);
<span class="keyword">const</span> type = <span class="built_in">Reflect</span>.apply(<span class="built_in">Object</span>.prototype.toString, youngest);
</code></pre>
<h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>{
  <span class="comment">/*…*/</span>
}

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.defineProperty(MyDate, <span class="string">'now'</span>, {
  <span class="attr">value</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>.now()
});

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.defineProperty(MyDate, <span class="string">'now'</span>, {
  <span class="attr">value</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>.now()
});
</code></pre>
<p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p>
<h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {};
<span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'hidden'</span>, {
  <span class="attr">value</span>: <span class="literal">true</span>,
  <span class="attr">enumerable</span>: <span class="literal">false</span>,
});

<span class="comment">// 旧写法</span>
<span class="keyword">var</span> theDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);

<span class="comment">// 新写法</span>
<span class="keyword">var</span> theDescriptor = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);
</code></pre>
<p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p>
<h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObject = {};

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.isExtensible(myObject) <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.isExtensible(myObject) <span class="comment">// true</span>
</code></pre>
<p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.isExtensible(<span class="number">1</span>) <span class="comment">// false</span>
<span class="built_in">Reflect</span>.isExtensible(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {};

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.isExtensible(myObject) <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.preventExtensions(myObject) <span class="comment">// true</span>
</code></pre>
<p>如果参数不是对象，<code>Object.isExtensible</code>在 ES5 环境报错，在 ES6 环境返回这个参数，而<code>Reflect.preventExtensions</code>会报错。</p>
<pre><code class="javascript"><span class="comment">// ES5</span>
<span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 报错</span>

<span class="comment">// ES6</span>
<span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 1</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  <span class="attr">bar</span>: <span class="number">2</span>,
  [<span class="built_in">Symbol</span>.for(<span class="string">'baz'</span>)]: <span class="number">3</span>,
  [<span class="built_in">Symbol</span>.for(<span class="string">'bing'</span>)]: <span class="number">4</span>,
};

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.getOwnPropertyNames(myObject)
<span class="comment">// ['foo', 'bar']</span>

<span class="built_in">Object</span>.getOwnPropertySymbols(myObject)
<span class="comment">//[Symbol.for('baz'), Symbol.for('bing')]</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.ownKeys(myObject)
<span class="comment">// ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]</span>
</code></pre>
<h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<pre><code class="javascript"><span class="keyword">const</span> person = observable({
  <span class="attr">name</span>: <span class="string">'张三'</span>,
  <span class="attr">age</span>: <span class="number">20</span>
});

<span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${person.name}</span>, <span class="subst">${person.age}</span>`</span>)
}

observe(print);
person.name = <span class="string">'李四'</span>;
<span class="comment">// 输出</span>
<span class="comment">// 李四, 20</span>
</code></pre>
<p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p>
<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<pre><code class="javascript"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();

<span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);
<span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {set});

<span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>{
  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);
  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());
  <span class="keyword">return</span> result;
}
</code></pre>
<p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>
</div></header></article><section class="reward"> <a href="#" class="btn-reward">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png"></div></section></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016-2017 microzz</div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/2017/04/19/react-news/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/2017/04/19/regex/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>