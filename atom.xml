<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ECUT Club</title>
  <subtitle>东华理工大学 IT技术交流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ecut.club/"/>
  <updated>2017-04-01T15:20:00.000Z</updated>
  <id>http://ecut.club/</id>
  
  <author>
    <name>microzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/WebReader/"/>
    <id>http://ecut.club/2017/04/19/WebReader/</id>
    <published>2017-04-19T00:24:13.835Z</published>
    <updated>2017-04-01T15:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 基于HTML5的Web阅读器<br>date: 2017-03-04 20:11:26<br>tags:</p>
<ul>
<li>JavaScript</li>
<li>HTML5</li>
<li>WebApp</li>
</ul>
<hr>
<h1 id="基于HTML5的Web阅读器"><a href="#基于HTML5的Web阅读器" class="headerlink" title="基于HTML5的Web阅读器"></a>基于HTML5的Web阅读器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是基于HTML5开发的简单的轻量级 WebApp在线阅读器，可以进行简单的个性化设置，适配了手机和电脑。运行需要一个Web服务器的支持。欢迎大家在我的<a href="https://github.com/microzz/WebReader" target="_blank" rel="external">GitHub</a>上Star，也可以提出宝贵意见哦😄</p>
<h2 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h2><p><img src="https://icdn.microzz.com/20170304_WebReader/web-reader.png" alt="基于HTML5的Web阅读器 - microzz.com"><br>在线预览地址1：🔗<a href="http://microzz.cn/web-reader/" target="_blank" rel="external">http://microzz.cn/web-reader/</a><br>在线预览地址2:🔗<a href="https://microzz.github.io/WebReader/" target="_blank" rel="external">https://microzz.github.io/WebReader/</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码地址：<a href="https://github.com/microzz/WebReader" target="_blank" rel="external">https://github.com/microzz/WebReader</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 基于HTML5的Web阅读器&lt;br&gt;date: 2017-03-04 20:11:26&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;HTML5&lt;/li&gt;
&lt;li&gt;WebApp&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/waterfalljq/"/>
    <id>http://ecut.club/2017/04/19/waterfalljq/</id>
    <published>2017-04-19T00:24:13.835Z</published>
    <updated>2017-02-20T14:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: jQuery实现一个瀑布流布局<br>date: 2017-02-20 21:42:02<br>tags:</p>
<ul>
<li>JavaScript</li>
<li>JS</li>
<li>waterfall</li>
<li>瀑布流</li>
<li>jQuery</li>
</ul>
<hr>
<h1 id="jQuery实现一个瀑布流布局"><a href="#jQuery实现一个瀑布流布局" class="headerlink" title="jQuery实现一个瀑布流布局"></a>jQuery实现一个瀑布流布局</h1><h2 id="瀑布流布局概念"><a href="#瀑布流布局概念" class="headerlink" title="瀑布流布局概念"></a>瀑布流布局概念</h2><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。</p>
<h2 id="瀑布流布局特点"><a href="#瀑布流布局特点" class="headerlink" title="瀑布流布局特点"></a>瀑布流布局特点</h2><ol>
<li>琳琅满目：整版以图片为主，大小不一的图片按照一定的规律排列。</li>
<li>唯美：图片的风格以唯美的图片为主。</li>
<li>操作简单：在浏览网站的时候只需要轻轻滑动一下鼠标滚轮，一切的美妙的图片精彩便可呈现在你面前。</li>
</ol>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p> 在线预览地址1： 🔗<a href="http://microzz.cn/waterfall-jq/" target="_blank" rel="external">http://microzz.cn/waterfall-jq/</a><br> 在线预览地址2： 🔗<a href="https://microzz.github.io/waterfall-jq/" target="_blank" rel="external">https://microzz.github.io/waterfall-jq/</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>源代码地址：🔗<a href="https://github.com/microzz/waterfall-jq" target="_blank" rel="external">https://github.com/microzz/waterfall-jq</a></p>
<h2 id="瀑布流布局优缺点"><a href="#瀑布流布局优缺点" class="headerlink" title="瀑布流布局优缺点"></a>瀑布流布局优缺点</h2><h3 id="布局优点"><a href="#布局优点" class="headerlink" title="布局优点"></a>布局优点</h3><ol>
<li>有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。</li>
<li>对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。</li>
<li>更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。<h3 id="布局缺点"><a href="#布局缺点" class="headerlink" title="布局缺点"></a>布局缺点</h3></li>
<li>有限的用例：<br>无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。<br>例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。</li>
<li>额外的复杂度：<br>那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。</li>
<li>再见了，页脚：<br>如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。<br>最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。<br>千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。</li>
<li>SEO：<br>集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。</li>
<li>关于页面数量的印象：<br>其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p> <a href="https://microzz.com/2017/02/17/waterfalljs/" target="_blank" rel="external">原生JavaScript实现瀑布流布局</a><br> <a href="https://microzz.com/2017/02/19/waterfallcss3/" target="_blank" rel="external">CSS3实现一个瀑布流布局</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: jQuery实现一个瀑布流布局&lt;br&gt;date: 2017-02-20 21:42:02&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;waterfall&lt;/li&gt;
&lt;li&gt;瀑布流&lt;/li
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/waterfalljs/"/>
    <id>http://ecut.club/2017/04/19/waterfalljs/</id>
    <published>2017-04-19T00:24:13.835Z</published>
    <updated>2017-02-20T14:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 原生JavaScript实现瀑布流布局<br>date: 2017-02-17 17:35:03<br>tags:</p>
<ul>
<li>JavaScript</li>
<li>JS</li>
<li>waterfall</li>
<li>瀑布流</li>
</ul>
<hr>
<h1 id="原生JavaScript实现一个瀑布流布局"><a href="#原生JavaScript实现一个瀑布流布局" class="headerlink" title="原生JavaScript实现一个瀑布流布局"></a>原生JavaScript实现一个瀑布流布局</h1><h2 id="瀑布流布局概念"><a href="#瀑布流布局概念" class="headerlink" title="瀑布流布局概念"></a>瀑布流布局概念</h2><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。</p>
<h2 id="瀑布流布局特点"><a href="#瀑布流布局特点" class="headerlink" title="瀑布流布局特点"></a>瀑布流布局特点</h2><ol>
<li>琳琅满目：整版以图片为主，大小不一的图片按照一定的规律排列。</li>
<li>唯美：图片的风格以唯美的图片为主。</li>
<li>操作简单：在浏览网站的时候只需要轻轻滑动一下鼠标滚轮，一切的美妙的图片精彩便可呈现在你面前。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>源代码地址：🔗<a href="https://github.com/microzz/waterfall-js" target="_blank" rel="external">https://github.com/microzz/waterfall-js</a></p>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p> 在线预览地址1： 🔗<a href="http://microzz.cn/waterfall/" target="_blank" rel="external">http://microzz.cn/waterfall/</a><br> 在线预览地址2： 🔗<a href="https://microzz.github.io/waterfall-js/" target="_blank" rel="external">https://microzz.github.io/waterfall-js/</a></p>
<h2 id="瀑布流布局优缺点"><a href="#瀑布流布局优缺点" class="headerlink" title="瀑布流布局优缺点"></a>瀑布流布局优缺点</h2><h3 id="布局优点"><a href="#布局优点" class="headerlink" title="布局优点"></a>布局优点</h3><ol>
<li>有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。</li>
<li>对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。</li>
<li>更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。<h3 id="布局缺点"><a href="#布局缺点" class="headerlink" title="布局缺点"></a>布局缺点</h3></li>
<li>有限的用例：<br>无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。<br>例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。</li>
<li>额外的复杂度：<br>那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。</li>
<li>再见了，页脚：<br>如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。<br>最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。<br>千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。</li>
<li>SEO：<br>集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。</li>
<li>关于页面数量的印象：<br>其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p> <a href="https://microzz.com/2017/02/19/waterfallcss3/" target="_blank" rel="external">CSS3实现一个瀑布流布局</a><br><a href="https://microzz.com/2017/02/20/waterfalljq/" target="_blank" rel="external">jQuery实现一个瀑布流布局</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 原生JavaScript实现瀑布流布局&lt;br&gt;date: 2017-02-17 17:35:03&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;waterfall&lt;/li&gt;
&lt;li&gt;瀑布流
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/waterfallcss3/"/>
    <id>http://ecut.club/2017/04/19/waterfallcss3/</id>
    <published>2017-04-19T00:24:13.819Z</published>
    <updated>2017-02-20T14:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: CSS3实现一个瀑布流布局<br>date: 2017-02-19 19:30:02<br>tags:</p>
<ul>
<li>JavaScript</li>
<li>JS</li>
<li>waterfall</li>
<li>瀑布流</li>
<li>CSS3</li>
</ul>
<hr>
<h1 id="CSS3实现一个瀑布流布局"><a href="#CSS3实现一个瀑布流布局" class="headerlink" title="CSS3实现一个瀑布流布局"></a>CSS3实现一个瀑布流布局</h1><h2 id="瀑布流布局概念"><a href="#瀑布流布局概念" class="headerlink" title="瀑布流布局概念"></a>瀑布流布局概念</h2><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。</p>
<h2 id="瀑布流布局特点"><a href="#瀑布流布局特点" class="headerlink" title="瀑布流布局特点"></a>瀑布流布局特点</h2><ol>
<li>琳琅满目：整版以图片为主，大小不一的图片按照一定的规律排列。</li>
<li>唯美：图片的风格以唯美的图片为主。</li>
<li>操作简单：在浏览网站的时候只需要轻轻滑动一下鼠标滚轮，一切的美妙的图片精彩便可呈现在你面前。</li>
</ol>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p> 在线预览地址1： 🔗<a href="http://microzz.cn/waterfall-css3/" target="_blank" rel="external">http://microzz.cn/waterfall-css3/</a><br> 在线预览地址2： 🔗<a href="https://microzz.github.io/waterfall-css3/" target="_blank" rel="external">https://microzz.github.io/waterfall-css3/</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>源代码地址：🔗<a href="https://github.com/microzz/waterfall-css3" target="_blank" rel="external">https://github.com/microzz/waterfall-css3</a></p>
<h2 id="瀑布流布局优缺点"><a href="#瀑布流布局优缺点" class="headerlink" title="瀑布流布局优缺点"></a>瀑布流布局优缺点</h2><h3 id="布局优点"><a href="#布局优点" class="headerlink" title="布局优点"></a>布局优点</h3><ol>
<li>有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。</li>
<li>对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。</li>
<li>更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。<h3 id="布局缺点"><a href="#布局缺点" class="headerlink" title="布局缺点"></a>布局缺点</h3></li>
<li>有限的用例：<br>无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。<br>例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。</li>
<li>额外的复杂度：<br>那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。</li>
<li>再见了，页脚：<br>如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。<br>最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。<br>千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。</li>
<li>SEO：<br>集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。</li>
<li>关于页面数量的印象：<br>其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p> <a href="https://microzz.com/2017/02/17/waterfalljs/" target="_blank" rel="external">原生JavaScript实现瀑布流布局</a><br><a href="https://microzz.com/2017/02/20/waterfalljq/" target="_blank" rel="external">jQuery实现一个瀑布流布局</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: CSS3实现一个瀑布流布局&lt;br&gt;date: 2017-02-19 19:30:02&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;waterfall&lt;/li&gt;
&lt;li&gt;瀑布流&lt;/li&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/vue-note/"/>
    <id>http://ecut.club/2017/04/19/vue-note/</id>
    <published>2017-04-19T00:24:13.819Z</published>
    <updated>2017-03-21T15:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Vue.js2.0学习笔记<br>date: 2017-03-20 22:30:39<br>tags:</p>
<ul>
<li>Vue.js</li>
<li>Vuex</li>
<li>JS</li>
<li>JavaScript</li>
</ul>
<hr>
<h1 id="Vue-js2-0学习笔记"><a href="#Vue-js2-0学习笔记" class="headerlink" title="Vue.js2.0学习笔记"></a>Vue.js2.0学习笔记</h1><h2 id="父子组件如何通信"><a href="#父子组件如何通信" class="headerlink" title="父子组件如何通信"></a>父子组件如何通信</h2><p>1.父子组件如何通信？</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>父组件监听一个事件，子组件触发该事件，并且可以传递自身数据。比如</li>
</ul>
<pre><code class="js">
// 父组件引入子组件
&lt;child v-on:tellFather="fatherFunc"&gt;&lt;/child&gt;

// 父组件 data 里面有 info
data() {
    return {
      info: ''
    }

// 父组件 methods 有 fatherFunc 方法
methods: {
    fatherFunc(msg) {
      this.info = msg
    }
  }

// 子组件 通过 childFunc 触发父组件监听的事件
&lt;button v-on:click="childFunc"&gt;Button&lt;/button&gt;

// 子组件 data 里面有 msg 信息要传给父组件
data() {
    return {
      msg: 'This is the message from child'
    }
  },

  // 子组件的 childFunc 方法
  methods: {
    childFunc() {

      // 关键！！！ 
      // 子组件触发父组件的 tellFather 事件，
      // 并可以传递自身 data 里面的数据给父组件
      this.$emit('tellFather', this.msg)
    }
  }
</code></pre>
<h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><ul>
<li>使用 Vuex 让不同组件间共享状态(state)</li>
</ul>
<h2 id="this-parent-message"><a href="#this-parent-message" class="headerlink" title="this.$parent.message"></a>this.$parent.message</h2><p>2.子组件中使用<code>this.$parent.message</code>可以获取父亲data里面的message</p>
<h2 id="this-refs"><a href="#this-refs" class="headerlink" title="this.$refs"></a>this.$refs</h2><p>3.<code>this.$refs.img</code>可以获取ref属性为img的DOM元素</p>
<h2 id="event"><a href="#event" class="headerlink" title="$event"></a>$event</h2><p>4.有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p>
<pre><code class="javascript">&lt;button v-on:click="warn('Form cannot be submitted yet.', $event)"&gt;Submit&lt;/button&gt;
// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) event.preventDefault()
    alert(message)
  }
}
</code></pre>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>5.在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。<br>为了解决这个问题， Vue.js 为<code>v-on</code> 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。<br><code>.stop</code><br><code>.prevent</code><br><code>.capture</code><br><code>.self</code><br><code>.once</code></p>
<pre><code class="js">&lt;!-- 阻止单击事件冒泡 --&gt;
<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>
&lt;!-- 提交事件不再重载页面 --&gt;
<span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span>
&lt;!-- 修饰符可以串联  --&gt;
<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>
&lt;!-- 只有修饰符 --&gt;
<span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span>
&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;
<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;
<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
</code></pre>
<h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>6.一开始好多人会忽视 <code>name</code> 的属性，为什么要给组件写上 <code>name</code> 呢？</p>
<ul>
<li><p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p>
</li>
<li><p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools, 未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>, 这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p>
</li>
</ul>
<h2 id="Vuex-action"><a href="#Vuex-action" class="headerlink" title="Vuex action"></a>Vuex action</h2><p>7.<strong>Vuex</strong>中 Mutations 必须是<em>同步</em>的，Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意<em>异步</em>操作。</p>
<p><strong><em>未完待续…</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Vue.js2.0学习笔记&lt;br&gt;date: 2017-03-20 22:30:39&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue.js&lt;/li&gt;
&lt;li&gt;Vuex&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/vue-music2/"/>
    <id>http://ecut.club/2017/04/19/vue-music2/</id>
    <published>2017-04-19T00:24:13.803Z</published>
    <updated>2017-04-10T01:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Vue.js音乐播放器升级版<br>date: 2017-04-08 07:08:28<br>tags:</p>
<ul>
<li>Vue.js</li>
<li>JavaScript</li>
<li>ES6</li>
<li>JS</li>
<li>ECMAScript6</li>
<li>HTML5</li>
<li>SASS</li>
<li>SCSS</li>
</ul>
<hr>
<h1 id="Vue-js音乐播放器2-0升级版"><a href="#Vue-js音乐播放器2-0升级版" class="headerlink" title="Vue.js音乐播放器2.0升级版"></a>Vue.js音乐播放器2.0升级版</h1><p>之前初学Vue做了一个音乐播放器，受到不少人的喜欢。现在升级版来了！功能更强，技术栈更多。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码地址：👉 <a href="https://github.com/microzz/vue-music-player" target="_blank" rel="external">GitHub</a><br>欢迎大家star和follow😄</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h3><p>在线预览地址：👉 <a href="https://microzz.com/vue-music/" target="_blank" rel="external">Vue音乐播放器</a></p>
<h3 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h3><p><img src="https://icdn.microzz.com/20170408_vue_music/preview.gif" alt="Vue音乐播放器升级版 - microzz.com"><br>更多预览图请看👉 <a href="https://github.com/microzz/vue-music-player/tree/2.0.0/preview" target="_blank" rel="external">更多</a></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p><strong>Vue2</strong>：采用最新Vue2的语法😁<br><strong>Vuex</strong>：实现不同组件之间的状态共享✌️<br><strong>vue-router</strong>：单页应用路由管理必备😎<br><strong>axios</strong>：发起http请求😉<br><strong>SASS(SCSS)</strong>：css预处理语言💪<br><strong>Express</strong>(上线版本是<strong>Koa2</strong>)：因为vue-cli是用的Express做服务器，所以开源的开发版本是Express，自己生产环境用的是Koa2。 😜<br><strong>Webpack</strong>：自动化构建工具，大部分配置vue-cli脚手架已经弄好了，很方便。😏<br><strong>ES6</strong>：采用ES6语法，这是趋势。👏<br><strong>localStorage(HTML5)</strong>：本地存储，保存用户个性化设置。😊<br><strong>CSS3</strong>：CSS3动画及样式。👍</p>
<h2 id="使用-Build-Setup"><a href="#使用-Build-Setup" class="headerlink" title="使用 Build Setup"></a>使用 Build Setup</h2><pre><code class="bash"><span class="comment"># install dependencies</span>
npm install

<span class="comment"># serve with hot reload at localhost:8080</span>
npm run dev

<span class="comment"># build for production with minification</span>
npm run build

<span class="comment"># build for production and view the bundle analyzer report</span>
npm run build --report
</code></pre>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li><p>vuex什么时候使用，如何使用，就要看项目需要。引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
</blockquote>
<p>各组件之间状态共享也是难点。</p>
</li>
<li><p>异步编程：JS是单线程，异步编程尤为重要。当我们向后端请求数据，是异步的，如果没有处理好相关的异步操作，是会有各种问题的。JS可以利用<code>setTimeout</code>、<code>回调</code>、<code>Generator</code>、<code>Promise</code>、<code>Async</code>。<br>定时这种方式太麻烦，还是不推荐；回调层次多了，有回调地狱，代码维护性很差；Generator需要手动去执行，当然可以使用类似<code>co</code>的模块。相比之下<code>Promise</code>和<code>Async</code>是比较理想的。(详看👉<a href="https://microzz.com/2017/01/14/promise/" target="_blank" rel="external">Promise对象</a>、<a href="https://microzz.com/2017/01/15/async/" target="_blank" rel="external">异步操作和Async函数</a>)</p>
</li>
<li>本项目中使用了QQ音乐和One(一个)的接口，后端API编写也是难点，包含了各种异步请求。对返回数据的解析也是难点，有的时候你还需要对数据进行解码。</li>
<li>各组件结构的设计：一开始大纲没设计好，后面想修改涉及面会很广。</li>
<li>过渡动画让交互更有趣，但是有的还是耗性能的，有设备差异，没用好会造成卡顿。</li>
</ol>
<p>【声明】：本项目仅供学习交流，请不要用做任何商业用途😊有任何疑问请联系作者📩<a href="mailto:zhaohui@microzz.com" target="_blank" rel="external">zhaohui@microzz.com</a></p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>源代码地址：👉 <a href="https://github.com/microzz/vue-music-player" target="_blank" rel="external">GitHub</a><br>个人网站：🔗<a href="https://microzz.com/" target="_blank" rel="external">microzz-IT技术分享</a><br>GitHub：🔗<a href="https://github.com/microzz" target="_blank" rel="external">microzz</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Vue.js音乐播放器升级版&lt;br&gt;date: 2017-04-08 07:08:28&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue.js&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;ES6&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/vue-music/"/>
    <id>http://ecut.club/2017/04/19/vue-music/</id>
    <published>2017-04-19T00:24:13.803Z</published>
    <updated>2017-04-10T01:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Vue.js写一个音乐播放器<br>date: 2017-03-15 21:44:02<br>tags:</p>
<ul>
<li>Vue.js</li>
<li>JavaScript</li>
<li>ES6</li>
<li>JS</li>
<li>ECMAScript6</li>
<li>HTML5</li>
</ul>
<hr>
<h1 id="Vue-js写一个音乐播放器"><a href="#Vue-js写一个音乐播放器" class="headerlink" title="Vue.js写一个音乐播放器"></a>Vue.js写一个音乐播放器</h1><h1 id="Vue音乐播放器2-0升级版已经发布，请看👉-Vue-js音乐播放器升级版"><a href="#Vue音乐播放器2-0升级版已经发布，请看👉-Vue-js音乐播放器升级版" class="headerlink" title="Vue音乐播放器2.0升级版已经发布，请看👉 Vue.js音乐播放器升级版"></a>Vue音乐播放器2.0升级版已经发布，请看👉 <a href="https://microzz.com/2017/04/08/vue-music2/" target="_blank" rel="external">Vue.js音乐播放器升级版</a></h1><h2 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h2><p><strong>2.0版本预览地址</strong>：🔗<a href="https://microzz.com/vue-music/" target="_blank" rel="external">https://microzz.com/vue-music/</a><br>在线预览地址1: 🔗<a href="http://microzz.cn/vue-music/" target="_blank" rel="external">http://microzz.cn/vue-music/</a><br>在线预览地址2: 🔗<a href="https://microzz.github.io/vue-music-player/" target="_blank" rel="external">https://microzz.github.io/vue-music-player/</a></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>GitHub地址: 🔗<a href="https://github.com/microzz/vue-music-player" target="_blank" rel="external">https://github.com/microzz/vue-music-player</a><br>欢迎大家follow和star哦😄</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>学习Vue.js后，决定做个小项目锻炼一下，于是选择了典型的音乐播放器上手。其中遇到了很多坑，也学到了很多。代码可能还有瑕疵，欢迎大家到我的<a href="https://github.com/microzz/vue-music-player" target="_blank" rel="external">GitHub</a>反馈，相互交流学习。同时也欢迎大家follow和star😄<br>预览图：<br><img src="https://icdn.microzz.com/20170315_vue_music/red.png" alt="红色皮肤-microzz.com"><br><img src="https://icdn.microzz.com/20170315_vue_music/green.png" alt="绿色皮肤-microzz.com"><br><img src="https://icdn.microzz.com/20170315_vue_music/blue.png" alt="蓝色皮肤-microzz.com"><br><img src="https://icdn.microzz.com/20170315_vue_music/black.png" alt="黑色皮肤-microzz.com"></p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a><strong>Vue.js</strong></h4><p>Vue的双向数据绑定真的很爽，让开发者更多的关注业务逻辑，而不是耗性能的DOM操作。借鉴了React.js和Angular.js等著名框架，Vue写起来也的确很方便，很多地方也想的很周到。因为实际场景，并没有使用到路由、vuex等东西。<br>其中也遇到了几个值得注意的地方：</p>
<ol>
<li>用好<code>watch</code>会事半功倍</li>
<li>有些操作要在实例加载完，所以钩子函数<code>mounted</code>需要注意</li>
<li>很多小技巧要试过才知道走了弯路😂</li>
</ol>
<hr>
<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><strong>ES6</strong></h4><p>本示例采用的是ES6的语法，因为webpack编译，所以也不必太过当心兼容性问题。ES6也即ECMAScript 2015，发布也有一段时间了，很多地方很方便，这是大势所趋，以后会慢慢地向ES6迁移。掌握是很必要的！</p>
<hr>
<h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><p><strong>localStorage</strong><br>本demo用localStorage本地存储保存用户设置（如：皮肤）和用户歌单列表</p>
<hr>
<h4 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h4><p>很多动画都是依靠CSS3完成的，方便性能也不错，缺点是兼容性问题。</p>
<hr>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><h3 id="2017-03-13"><a href="#2017-03-13" class="headerlink" title="2017.03.13"></a>2017.03.13</h3><p>A music player by Vue.js。一个由Vue.js写的音乐播放器，今天完成了播放器的大体功能，数据是通过JSON模拟</p>
<h4 id="后续完善"><a href="#后续完善" class="headerlink" title="后续完善"></a>后续完善</h4><ol>
<li>搭建后台调用网上音乐API</li>
<li>完善功能</li>
</ol>
<hr>
<h3 id="2017-03-14"><a href="#2017-03-14" class="headerlink" title="2017.03.14"></a>2017.03.14</h3><p>列表部分功能完善，部分代码优化，部分异步代码Promise化</p>
<h4 id="后续完善-1"><a href="#后续完善-1" class="headerlink" title="后续完善"></a>后续完善</h4><ol>
<li>冗余代码整合优化</li>
<li>部分代码封装</li>
</ol>
<hr>
<h3 id="2017-03-15"><a href="#2017-03-15" class="headerlink" title="2017.03.15"></a>2017.03.15</h3><p>1.0.0正式版发布</p>
<hr>
<h3 id="2017-03-19"><a href="#2017-03-19" class="headerlink" title="2017.03.19"></a>2017.03.19</h3><p>2.0.0版本筹划…</p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>个人网站：🔗<a href="https://microzz.com/" target="_blank" rel="external">https://microzz.com/</a><br>GitHub：🔗<a href="https://github.com/microzz" target="_blank" rel="external">https://github.com/microzz</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Vue.js写一个音乐播放器&lt;br&gt;date: 2017-03-15 21:44:02&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue.js&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;ES6&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/vue-cnode/"/>
    <id>http://ecut.club/2017/04/19/vue-cnode/</id>
    <published>2017-04-19T00:24:13.788Z</published>
    <updated>2017-04-17T09:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Vue.js打造一个开源的CNode社区<br>date: 2017-04-17 17:04:19<br>tags:</p>
<ul>
<li>Vue.js</li>
<li>Vuex</li>
<li>ES6</li>
<li>SCSS</li>
<li>ECMAScript6</li>
</ul>
<hr>
<h1 id="Vue-js打造一个开源的CNode社区"><a href="#Vue-js打造一个开源的CNode社区" class="headerlink" title="Vue.js打造一个开源的CNode社区"></a>Vue.js打造一个开源的CNode社区</h1><p>Vue.js打造一个开源的CNode社区，实现了浏览、发帖、收藏、回复、点赞、个人中心等等功能。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码地址：👉 <a href="https://github.com/microzz/vue-cnode" target="_blank" rel="external">https://github.com/microzz/vue-cnode</a></p>
<p>欢迎大家star和fork😄</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>在线预览地址：👉 <a href="https://microzz.com/vue-cnode/" target="_blank" rel="external">https://microzz.com/vue-cnode/</a></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>Vue2.0</strong>：前端页面展示。</li>
<li><strong>Vuex</strong>：Vuex，实现不同组件间的状态共享</li>
<li><strong>vue-router</strong>：页面路由切换</li>
<li><strong>axios</strong>：一个基于 <code>Promise</code> 的 HTTP 库，向后端发起请求。</li>
<li><strong>Express</strong>、<strong>Koa2</strong>：因为vue-cli生成的项目是基于<strong>express</strong>的，所以在开发阶段我使用的是它，但是真正上线生产环境我换成了<strong>Koa2</strong>。</li>
<li><strong>Moment.js</strong>：一个时间处理的库，方便对时间进行格式化成需要的格式，如主题、回复时间显示”<em> 分钟前、</em> 小时前、*天前”等等。</li>
<li><strong>ES6</strong>、<strong>ES7</strong>：采用ES6语法，这是以后的趋势。箭头函数、Promise等等语法很好用。</li>
<li><strong>localStorage</strong>：保存用户信息。</li>
<li><strong>Canvas</strong>：页面顶部小雪花效果。</li>
<li><strong>Webpack</strong>：vue-cli自带Webpack，但是需要自己改造一下，比如要对需要安装sass相关loader，vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要<code>&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;</code>。</li>
<li><strong>SASS</strong>(<strong>SCSS</strong>)：用SCSS做CSS预处理语言，有些地方很方便，个人很喜欢用。(详看👉<a href="https://microzz.com/2017/03/18/sass/" target="_blank" rel="external">SASS用法指南</a>)</li>
<li><strong>flex</strong>：flex弹性布局，<strong>简单</strong>适配手机、PC端。</li>
<li><strong>CSS3</strong>：CSS3过渡动画及样式。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>组件状态多了用Vuex管理很方便，引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
</blockquote>
</li>
<li><p>事先一定要先想好整个页面组成，怎样去分组件开发，这样在开发阶段会事半功倍。</p>
</li>
<li>Moment.js在Vue中用ES6的方式引入会有问题，可以尝试在main.js尝试这样<code>import moment from &#39;moment&#39;</code> <code>Vue.prototype.moment = moment;</code>给Vue的原型上添加moment，这样就可以在Vue的实例中随意使用它了。</li>
<li>项目结构如下图</li>
</ol>
<p><img src="https://icdn.microzz.com/20170417_vue_cnode/vue_cnode.png" alt="Vue-CNode by microzz.com"></p>
<h2 id="时间轨迹"><a href="#时间轨迹" class="headerlink" title="时间轨迹"></a>时间轨迹</h2><ul>
<li><p><strong>4.13</strong>：基本功能完成，后续完成登录后的操作。</p>
</li>
<li><p><strong>4.14</strong>：完成登录以及侧边栏。</p>
</li>
<li><p><strong>4.15</strong>：增加收藏</p>
</li>
<li><p><strong>4.16</strong>：加入回复、单条回复、点赞。项目完成。</p>
</li>
</ul>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>源代码地址：👉 <a href="https://github.com/microzz/vue-cnode" target="_blank" rel="external">GitHub</a></p>
<p>个人网站：👉 <a href="https://microzz.com/" target="_blank" rel="external">microzz.com</a></p>
<p>GitHub：👉 <a href="https://github.com/microzz" target="_blank" rel="external">microzz</a></p>
<h2 id="Build-Setup"><a href="#Build-Setup" class="headerlink" title="Build Setup"></a>Build Setup</h2><pre><code class="bash"><span class="comment"># install dependencies</span>
npm install

<span class="comment"># serve with hot reload at localhost:8080</span>
npm run dev

<span class="comment"># build for production with minification</span>
npm run build

<span class="comment"># build for production and view the bundle analyzer report</span>
npm run build --report
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Vue.js打造一个开源的CNode社区&lt;br&gt;date: 2017-04-17 17:04:19&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue.js&lt;/li&gt;
&lt;li&gt;Vuex&lt;/li&gt;
&lt;li&gt;ES6&lt;/li&gt;
&lt;li&gt;SCSS&lt;/li&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/vue-begin/"/>
    <id>http://ecut.club/2017/04/19/vue-begin/</id>
    <published>2017-04-19T00:24:13.788Z</published>
    <updated>2017-03-10T00:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Vue.js初体验-TodoList<br>date: 2017-03-09 22:51:14<br>tags:</p>
<pre><code>- Vue.js
- JavaScript
- JS
- ES6
- ECMAScript6
</code></pre><hr>
<h1 id="Vue-js初体验"><a href="#Vue-js初体验" class="headerlink" title="Vue.js初体验"></a>Vue.js初体验</h1><blockquote>
<p>&nbsp;&nbsp;&nbsp;之前学了React.js，今天简单上手了Vue.js，感受到了Vue.js的一些独特魅力。双向的数据绑定让人开发起来很“爽”，于是动手简单写了一个Todo List小demo，Vue上手的确比较简单，方便不少。期待后续的学习😄</p>
</blockquote>
<h2 id="TodoList小demo"><a href="#TodoList小demo" class="headerlink" title="TodoList小demo"></a>TodoList小demo</h2><h3 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h3><p>在线预览地址1: 🔗<a href="http://microzz.cn/todo-vue/" target="_blank" rel="external">http://microzz.cn/todo-vue/</a><br>在线预览地址2: 🔗<a href="https://microzz.github.io/todo-list-vuejs/" target="_blank" rel="external">https://microzz.github.io/todo-list-vuejs/</a></p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>源代码地址：🔗<a href="https://github.com/microzz/todo-list-vuejs" target="_blank" rel="external">https://github.com/microzz/todo-list-vuejs</a></p>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。<br>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>易用</strong><br>已经会了HTML,CSS,JavaScript？即刻阅读指南开始构建应用！</li>
<li><strong>灵活</strong><br>简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。</li>
<li><strong>性能</strong><br>17kb min+gzip 运行大小<br>超快虚拟 DOM<br>最省心的优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Vue.js初体验-TodoList&lt;br&gt;date: 2017-03-09 22:51:14&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Vue.js
- JavaScript
- JS
- ES6
- ECMAScript6
&lt;/code
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/symbol/"/>
    <id>http://ecut.club/2017/04/19/symbol/</id>
    <published>2017-04-19T00:24:13.788Z</published>
    <updated>2017-01-12T08:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Symbol<br>date: 2017-01-01 13:43:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JS
- ES6
- Symbol
</code></pre><hr>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。</p>
<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<pre><code class="javascript"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();

<span class="keyword">typeof</span> s
<span class="comment">// "symbol"</span>
</code></pre>
<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是Symbol数据类型，而不是字符串之类的其他类型。</p>
<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<pre><code class="javascript"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);
<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);

s1 <span class="comment">// Symbol(foo)</span>
s2 <span class="comment">// Symbol(bar)</span>

s1.toString() <span class="comment">// "Symbol(foo)"</span>
s2.toString() <span class="comment">// "Symbol(bar)"</span>
</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>是两个Symbol值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<pre><code class="javascript"><span class="keyword">const</span> obj = {
  toString() {
    <span class="keyword">return</span> <span class="string">'abc'</span>;
  }
};
<span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);
sym <span class="comment">// Symbol(abc)</span>
</code></pre>
<p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
<pre><code class="javascript"><span class="comment">// 没有参数的情况</span>
<span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();
<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();

s1 === s2 <span class="comment">// false</span>

<span class="comment">// 有参数的情况</span>
<span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);
<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);

s1 === s2 <span class="comment">// false</span>
</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol值不能与其他类型的值进行运算，会报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);

<span class="string">"your symbol is "</span> + sym
<span class="comment">// TypeError: can't convert symbol to string</span>
<span class="string">`your symbol is <span class="subst">${sym}</span>`</span>
<span class="comment">// TypeError: can't convert symbol to string</span>
</code></pre>
<p>但是，Symbol值可以显式转为字符串。</p>
<pre><code class="javascript"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);

<span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span>
sym.toString() <span class="comment">// 'Symbol(My symbol)'</span>
</code></pre>
<p>另外，Symbol值也可以转为布尔值，但是不能转为数值。</p>
<pre><code class="javascript"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>();
<span class="built_in">Boolean</span>(sym) <span class="comment">// true</span>
!sym  <span class="comment">// false</span>

<span class="keyword">if</span> (sym) {
  <span class="comment">// ...</span>
}

<span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span>
sym + <span class="number">2</span> <span class="comment">// TypeError</span>
</code></pre>
<h2 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<pre><code class="javascript"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();

<span class="comment">// 第一种写法</span>
<span class="keyword">var</span> a = {};
a[mySymbol] = <span class="string">'Hello!'</span>;

<span class="comment">// 第二种写法</span>
<span class="keyword">var</span> a = {
  [mySymbol]: <span class="string">'Hello!'</span>
};

<span class="comment">// 第三种写法</span>
<span class="keyword">var</span> a = {};
<span class="built_in">Object</span>.defineProperty(a, mySymbol, { <span class="attr">value</span>: <span class="string">'Hello!'</span> });

<span class="comment">// 以上写法都得到同样结果</span>
a[mySymbol] <span class="comment">// "Hello!"</span>
</code></pre>
<p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个Symbol值。</p>
<p>注意，Symbol值作为对象属性名时，不能用点运算符。</p>
<pre><code class="javascript"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();
<span class="keyword">var</span> a = {};

a.mySymbol = <span class="string">'Hello!'</span>;
a[mySymbol] <span class="comment">// undefined</span>
a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span>
</code></pre>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个Symbol值。</p>
<p>同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p>
<pre><code class="javascript"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();

<span class="keyword">let</span> obj = {
  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>{ ... }
};

obj[s](<span class="number">123</span>);
</code></pre>
<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个Symbol值。</p>
<p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p>
<pre><code class="javascript"><span class="keyword">let</span> obj = {
  [s](arg) { ... }
};
</code></pre>
<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<pre><code class="javascript">log.levels = {
  <span class="attr">DEBUG</span>: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),
  <span class="attr">INFO</span>: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),
  <span class="attr">WARN</span>: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)
};
log(log.levels.DEBUG, <span class="string">'debug message'</span>);
log(log.levels.INFO, <span class="string">'info message'</span>);
</code></pre>
<p>下面是另外一个例子。</p>
<pre><code class="javascript"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();
<span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();

<span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>{
  <span class="keyword">switch</span> (color) {
    <span class="keyword">case</span> COLOR_RED:
      <span class="keyword">return</span> COLOR_GREEN;
    <span class="keyword">case</span> COLOR_GREEN:
      <span class="keyword">return</span> COLOR_RED;
    <span class="keyword">default</span>:
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);
    }
}
</code></pre>
<p>常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>
<p>还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h2 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>{
  <span class="keyword">var</span> area = <span class="number">0</span>;

  <span class="keyword">switch</span> (shape) {
    <span class="keyword">case</span> <span class="string">'Triangle'</span>: <span class="comment">// 魔术字符串</span>
      area = <span class="number">.5</span> * options.width * options.height;
      <span class="keyword">break</span>;
    <span class="comment">/* ... more code ... */</span>
  }

  <span class="keyword">return</span> area;
}

getArea(<span class="string">'Triangle'</span>, { <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> }); <span class="comment">// 魔术字符串</span>
</code></pre>
<p>上面代码中，字符串“Triangle”就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<pre><code class="javascript"><span class="keyword">var</span> shapeType = {
  <span class="attr">triangle</span>: <span class="string">'Triangle'</span>
};

<span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>{
  <span class="keyword">var</span> area = <span class="number">0</span>;
  <span class="keyword">switch</span> (shape) {
    <span class="keyword">case</span> shapeType.triangle:
      area = <span class="number">.5</span> * options.width * options.height;
      <span class="keyword">break</span>;
  }
  <span class="keyword">return</span> area;
}

getArea(shapeType.triangle, { <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> });
</code></pre>
<p>上面代码中，我们把“Triangle”写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用Symbol值。</p>
<pre><code class="javascript"><span class="keyword">const</span> shapeType = {
  <span class="attr">triangle</span>: <span class="built_in">Symbol</span>()
};
</code></pre>
<p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个Symbol，其他地方都不用修改。</p>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = {};
<span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);
<span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);

obj[a] = <span class="string">'Hello'</span>;
obj[b] = <span class="string">'World'</span>;

<span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);

objectSymbols
<span class="comment">// [Symbol(a), Symbol(b)]</span>
</code></pre>
<p>下面是另一个例子，<code>Object.getOwnPropertySymbols</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = {};

<span class="keyword">var</span> foo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);

<span class="built_in">Object</span>.defineProperty(obj, foo, {
  <span class="attr">value</span>: <span class="string">"foobar"</span>,
});

<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) {
  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出</span>
}

<span class="built_in">Object</span>.getOwnPropertyNames(obj)
<span class="comment">// []</span>

<span class="built_in">Object</span>.getOwnPropertySymbols(obj)
<span class="comment">// [Symbol(foo)]</span>
</code></pre>
<p>上面代码中，使用<code>Object.getOwnPropertyNames</code>方法得不到<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法。</p>
<p>另一个新的API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<pre><code class="javascript"><span class="keyword">let</span> obj = {
  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,
  <span class="attr">enum</span>: <span class="number">2</span>,
  <span class="attr">nonEnum</span>: <span class="number">3</span>
};

<span class="built_in">Reflect</span>.ownKeys(obj)
<span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span>
</code></pre>
<p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<pre><code class="javascript"><span class="keyword">var</span> size = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);

<span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>{
  <span class="keyword">constructor</span>() {
    <span class="keyword">this</span>[size] = <span class="number">0</span>;
  }

  add(item) {
    <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;
    <span class="keyword">this</span>[size]++;
  }

  <span class="keyword">static</span> sizeOf(instance) {
    <span class="keyword">return</span> instance[size];
  }
}

<span class="keyword">var</span> x = <span class="keyword">new</span> Collection();
Collection.sizeOf(x) <span class="comment">// 0</span>

x.add(<span class="string">'foo'</span>);
Collection.sizeOf(x) <span class="comment">// 1</span>

<span class="built_in">Object</span>.keys(x) <span class="comment">// ['0']</span>
<span class="built_in">Object</span>.getOwnPropertyNames(x) <span class="comment">// ['0']</span>
<span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span>
</code></pre>
<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<pre><code class="javascript"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);
<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);

s1 === s2 <span class="comment">// true</span>
</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30次，会返回30个不同的Symbol值。</p>
<pre><code class="javascript"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)
<span class="comment">// true</span>

<span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)
<span class="comment">// false</span>
</code></pre>
<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);
<span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span>

<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);
<span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span>
</code></pre>
<p>上面代码中，变量<code>s2</code>属于未登记的Symbol值，所以返回<code>undefined</code>。</p>
<p>需要注意的是，<code>Symbol.for</code>为Symbol值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p>
<pre><code class="javascript">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);
iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);
<span class="built_in">document</span>.body.appendChild(iframe);

iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)
<span class="comment">// true</span>
</code></pre>
<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><p>Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p>
<pre><code class="javascript"><span class="comment">// mod.js</span>
<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>{
  <span class="keyword">this</span>.foo = <span class="string">'hello'</span>;
}

<span class="keyword">if</span> (!global._foo) {
  global._foo = <span class="keyword">new</span> A();
}

<span class="built_in">module</span>.exports = global._foo;
</code></pre>
<p>然后，加载上面的<code>mod.js</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);
<span class="built_in">console</span>.log(a.foo);
</code></pre>
<p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>
<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>
<pre><code class="javascript"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);
global._foo = <span class="number">123</span>;
</code></pre>
<p>上面的代码，会使得别的脚本加载<code>mod.js</code>都失真。</p>
<p>为了防止这种情况出现，我们就可以使用Symbol。</p>
<pre><code class="javascript"><span class="comment">// mod.js</span>
<span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>{
  <span class="keyword">this</span>.foo = <span class="string">'hello'</span>;
}

<span class="keyword">if</span> (!global[FOO_KEY]) {
  global[FOO_KEY] = <span class="keyword">new</span> A();
}

<span class="built_in">module</span>.exports = global[FOO_KEY];
</code></pre>
<p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>
<pre><code class="javascript"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);
global[<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)] = <span class="number">123</span>;
</code></pre>
<p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>
<pre><code class="javascript"><span class="comment">// mod.js</span>
<span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);

<span class="comment">// 后面代码相同 ……</span>
</code></pre>
<p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然Node会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。</p>
<h2 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h2><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{
  [<span class="built_in">Symbol</span>.hasInstance](foo) {
    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;
  }
}

[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">// true</span>
</code></pre>
<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>{
  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) {
    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;
  }
}

<span class="number">1</span> <span class="keyword">instanceof</span> Even <span class="comment">// false</span>
<span class="number">2</span> <span class="keyword">instanceof</span> Even <span class="comment">// true</span>
<span class="number">12345</span> <span class="keyword">instanceof</span> Even <span class="comment">// false</span>
</code></pre>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开。</p>
<pre><code class="javascript"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];
[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span>
arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span>

<span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];
arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;
[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', ['c','d'], 'e']</span>
</code></pre>
<p>上面代码说明，数组的默认行为是可以展开。<code>Symbol.isConcatSpreadable</code>属性等于<code>true</code>或<code>undefined</code>，都有这个效果。</p>
<p>类似数组的对象也可以展开，但它的<code>Symbol.isConcatSpreadable</code>属性默认为<code>false</code>，必须手动打开。</p>
<pre><code class="javascript"><span class="keyword">let</span> obj = {<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>};
[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', obj, 'e']</span>

obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;
[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span>
</code></pre>
<p>对于一个类来说，<code>Symbol.isConcatSpreadable</code>属性必须写成实例的属性。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>{
  <span class="keyword">constructor</span>(args) {
    <span class="keyword">super</span>(args);
    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>{
  <span class="keyword">constructor</span>(args) {
    <span class="keyword">super</span>(args);
    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;
  }
}
<span class="keyword">let</span> a1 = <span class="keyword">new</span> A1();
a1[<span class="number">0</span>] = <span class="number">3</span>;
a1[<span class="number">1</span>] = <span class="number">4</span>;
<span class="keyword">let</span> a2 = <span class="keyword">new</span> A2();
a2[<span class="number">0</span>] = <span class="number">5</span>;
a2[<span class="number">1</span>] = <span class="number">6</span>;
[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)
<span class="comment">// [1, 2, 3, 4, [5, 6]]</span>
</code></pre>
<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>{
  <span class="comment">// 覆盖父类 Array 的构造函数</span>
  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() { <span class="keyword">return</span> <span class="built_in">Array</span>; }
}
</code></pre>
<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>。创建<code>MyArray</code>的实例对象时，本来会调用它自己的构造函数（本例中被省略了），但是由于定义了<code>Symbol.species</code>属性，所以会使用这个属性返回的的函数，创建<code>MyArray</code>的实例。</p>
<p>这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>读取器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>
<pre><code class="javascript"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() {
  <span class="keyword">return</span> <span class="keyword">this</span>;
}
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>{
  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() { <span class="keyword">return</span> <span class="built_in">Array</span>; }
}
<span class="keyword">var</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);
<span class="keyword">var</span> mapped = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);

mapped <span class="keyword">instanceof</span> MyArray <span class="comment">// false</span>
mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span>
</code></pre>
<p>上面代码中，由于构造函数被替换成了<code>Array</code>。所以，<code>mapped</code>对象不是<code>MyArray</code>的实例，而是<code>Array</code>的实例。</p>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<pre><code class="javascript"><span class="built_in">String</span>.prototype.match(regexp)
<span class="comment">// 等同于</span>
regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)

<span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>{
  [<span class="built_in">Symbol</span>.match](string) {
    <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);
  }
}

<span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher()) <span class="comment">// 1</span>
</code></pre>
<h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>
<pre><code class="javascript"><span class="built_in">String</span>.prototype.replace(searchValue, replaceValue)
<span class="comment">// 等同于</span>
searchValue[<span class="built_in">Symbol</span>.replace](<span class="keyword">this</span>, replaceValue)
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">const</span> x = {};
x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);

<span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>) <span class="comment">// ["Hello", "World"]</span>
</code></pre>
<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>
<pre><code class="javascript"><span class="built_in">String</span>.prototype.search(regexp)
<span class="comment">// 等同于</span>
regexp[<span class="built_in">Symbol</span>.search](<span class="keyword">this</span>)

<span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>{
  <span class="keyword">constructor</span>(value) {
    <span class="keyword">this</span>.value = value;
  }
  [<span class="built_in">Symbol</span>.search](string) {
    <span class="keyword">return</span> string.indexOf(<span class="keyword">this</span>.value);
  }
}
<span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>)) <span class="comment">// 0</span>
</code></pre>
<h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>
<pre><code class="javascript"><span class="built_in">String</span>.prototype.split(separator, limit)
<span class="comment">// 等同于</span>
separator[<span class="built_in">Symbol</span>.split](<span class="keyword">this</span>, limit)
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">MySplitter</span> </span>{
  <span class="keyword">constructor</span>(value) {
    <span class="keyword">this</span>.value = value;
  }
  [<span class="built_in">Symbol</span>.split](string) {
    <span class="keyword">var</span> index = string.indexOf(<span class="keyword">this</span>.value);
    <span class="keyword">if</span> (index === <span class="number">-1</span>) {
      <span class="keyword">return</span> string;
    }
    <span class="keyword">return</span> [
      string.substr(<span class="number">0</span>, index),
      string.substr(index + <span class="keyword">this</span>.value.length)
    ];
  }
}

<span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'foo'</span>))
<span class="comment">// ['', 'bar']</span>

<span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'bar'</span>))
<span class="comment">// ['foo', '']</span>

<span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'baz'</span>))
<span class="comment">// 'foobar'</span>
</code></pre>
<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>
<pre><code class="javascript"><span class="keyword">var</span> myIterable = {};
myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>{
  <span class="keyword">yield</span> <span class="number">1</span>;
  <span class="keyword">yield</span> <span class="number">2</span>;
  <span class="keyword">yield</span> <span class="number">3</span>;
};

[...myIterable] <span class="comment">// [1, 2, 3]</span>
</code></pre>
<p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator和for…of循环》一章。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>{
  *[<span class="built_in">Symbol</span>.iterator]() {
    <span class="keyword">let</span> i = <span class="number">0</span>;
    <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) {
      <span class="keyword">yield</span> <span class="keyword">this</span>[i];
      ++i;
    }
  }
}

<span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();
myCollection[<span class="number">0</span>] = <span class="number">1</span>;
myCollection[<span class="number">1</span>] = <span class="number">2</span>;

<span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) {
  <span class="built_in">console</span>.log(value);
}
<span class="comment">// 1</span>
<span class="comment">// 2</span>
</code></pre>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串</li>
</ul>
<pre><code class="javascript"><span class="keyword">let</span> obj = {
  [<span class="built_in">Symbol</span>.toPrimitive](hint) {
    <span class="keyword">switch</span> (hint) {
      <span class="keyword">case</span> <span class="string">'number'</span>:
        <span class="keyword">return</span> <span class="number">123</span>;
      <span class="keyword">case</span> <span class="string">'string'</span>:
        <span class="keyword">return</span> <span class="string">'str'</span>;
      <span class="keyword">case</span> <span class="string">'default'</span>:
        <span class="keyword">return</span> <span class="string">'default'</span>;
      <span class="keyword">default</span>:
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();
     }
   }
};

<span class="number">2</span> * obj <span class="comment">// 246</span>
<span class="number">3</span> + obj <span class="comment">// '3default'</span>
obj == <span class="string">'default'</span> <span class="comment">// true</span>
<span class="built_in">String</span>(obj) <span class="comment">// 'str'</span>
</code></pre>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>
<pre><code class="javascript"><span class="comment">// 例一</span>
({[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Foo'</span>}.toString())
<span class="comment">// "[object Foo]"</span>

<span class="comment">// 例二</span>
<span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>{
  get [<span class="built_in">Symbol</span>.toStringTag]() {
    <span class="keyword">return</span> <span class="string">'xxx'</span>;
  }
}
<span class="keyword">var</span> x = <span class="keyword">new</span> Collection();
<span class="built_in">Object</span>.prototype.toString.call(x) <span class="comment">// "[object xxx]"</span>
</code></pre>
<p>ES6新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>
<ul>
<li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li>
<li><code>Math[Symbol.toStringTag]</code>：’Math’</li>
<li>Module对象<code>M[Symbol.toStringTag]</code>：’Module’</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li>
</ul>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>
<pre><code class="javascript"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]
<span class="comment">// {</span>
<span class="comment">//   copyWithin: true,</span>
<span class="comment">//   entries: true,</span>
<span class="comment">//   fill: true,</span>
<span class="comment">//   find: true,</span>
<span class="comment">//   findIndex: true,</span>
<span class="comment">//   keys: true</span>
<span class="comment">// }</span>

<span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])
<span class="comment">// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'keys']</span>
</code></pre>
<p>上面代码说明，数组有6个属性，会被with命令排除。</p>
<pre><code class="javascript"><span class="comment">// 没有unscopables时</span>
<span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{
  foo() { <span class="keyword">return</span> <span class="number">1</span>; }
}

<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="number">2</span>; };

<span class="keyword">with</span> (MyClass.prototype) {
  foo(); <span class="comment">// 1</span>
}

<span class="comment">// 有unscopables时</span>
<span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{
  foo() { <span class="keyword">return</span> <span class="number">1</span>; }
  get [<span class="built_in">Symbol</span>.unscopables]() {
    <span class="keyword">return</span> { <span class="attr">foo</span>: <span class="literal">true</span> };
  }
}

<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="number">2</span>; };

<span class="keyword">with</span> (MyClass.prototype) {
  foo(); <span class="comment">// 2</span>
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Symbol&lt;br&gt;date: 2017-01-01 13:43:19&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ECMAScript6
- JavaScript
- JS
- ES6
- Symbol
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/string/"/>
    <id>http://ecut.club/2017/04/19/string/</id>
    <published>2017-04-19T00:24:13.773Z</published>
    <updated>2017-01-12T07:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 字符串的扩展<br>date: 2016-11-15 15:45:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JS
- ES6
- Unicode
</code></pre><hr>
<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p>
<h2 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h2><p>JavaScript允许采用<code>\uxxxx</code>形式表示一个字符，其中“xxxx”表示字符的码点。</p>
<pre><code class="javascript"><span class="string">"\u0061"</span>
<span class="comment">// "a"</span>
</code></pre>
<p>但是，这种表示法只限于<code>\u0000</code>——<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p>
<pre><code class="javascript"><span class="string">"\uD842\uDFB7"</span>
<span class="comment">// "𠮷"</span>

<span class="string">"\u20BB7"</span>
<span class="comment">// " 7"</span>
</code></pre>
<p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<pre><code class="javascript"><span class="string">"\u{20BB7}"</span>
<span class="comment">// "𠮷"</span>

<span class="string">"\u{41}\u{42}\u{43}"</span>
<span class="comment">// "ABC"</span>

<span class="keyword">let</span> hello = <span class="number">123</span>;
hell\u{<span class="number">6</span>F} <span class="comment">// 123</span>

<span class="string">'\u{1F680}'</span> === <span class="string">'\uD83D\uDE80'</span>
<span class="comment">// true</span>
</code></pre>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。</p>
<p>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</p>
<pre><code class="javascript"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span>
<span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
<span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
<span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
<span class="string">'\u{7A}'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
</code></pre>
<h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">"𠮷"</span>;

s.length <span class="comment">// 2</span>
s.charAt(<span class="number">0</span>) <span class="comment">// ''</span>
s.charAt(<span class="number">1</span>) <span class="comment">// ''</span>
s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span>
s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span>
</code></pre>
<p>上面代码中，汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是<code>0x20BB7</code>，UTF-16编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6提供了<code>codePointAt</code>方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;

s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span>
s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span>

s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span>
</code></pre>
<p><code>codePointAt</code>方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。</p>
<p>总之，<code>codePointAt</code>方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt</code>方法相同。</p>
<p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;

s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// "20bb7"</span>
s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// "61"</span>
</code></pre>
<p>你可能注意到了，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是1，但是必须向<code>codePointAt</code>方法传入2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别32位的UTF-16字符。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;
<span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) {
  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));
}
<span class="comment">// 20bb7</span>
<span class="comment">// 61</span>
</code></pre>
<p><code>codePointAt</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>{
  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;
}

is32Bit(<span class="string">"𠮷"</span>) <span class="comment">// true</span>
is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span>
</code></pre>
<h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于<code>0xFFFF</code>）。</p>
<pre><code class="javascript"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)
<span class="comment">// "ஷ"</span>
</code></pre>
<p>上面代码中，<code>String.fromCharCode</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>
<p>ES6提供了<code>String.fromCodePoint</code>方法，可以识别<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。</p>
<pre><code class="javascript"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)
<span class="comment">// "𠮷"</span>
<span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span>
<span class="comment">// true</span>
</code></pre>
<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。</p>
<pre><code class="javascript"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) {
  <span class="built_in">console</span>.log(codePoint)
}
<span class="comment">// "f"</span>
<span class="comment">// "o"</span>
<span class="comment">// "o"</span>
</code></pre>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>
<pre><code class="javascript"><span class="keyword">var</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);

<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) {
  <span class="built_in">console</span>.log(text[i]);
}
<span class="comment">// " "</span>
<span class="comment">// " "</span>

<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) {
  <span class="built_in">console</span>.log(i);
}
<span class="comment">// "𠮷"</span>
</code></pre>
<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p>
<h2 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h2><p>ES5对字符串对象提供<code>charAt</code>方法，返回字符串给定位置的字符。该方法不能识别码点大于<code>0xFFFF</code>的字符。</p>
<pre><code class="javascript"><span class="string">'abc'</span>.charAt(<span class="number">0</span>) <span class="comment">// "a"</span>
<span class="string">'𠮷'</span>.charAt(<span class="number">0</span>) <span class="comment">// "\uD842"</span>
</code></pre>
<p>上面代码中，<code>charAt</code>方法返回的是UTF-16编码的第一个字节，实际上是无法显示的。</p>
<p>目前，有一个提案，提出字符串实例的<code>at</code>方法，可以识别Unicode编号大于<code>0xFFFF</code>的字符，返回正确的字符。</p>
<pre><code class="javascript"><span class="string">'abc'</span>.at(<span class="number">0</span>) <span class="comment">// "a"</span>
<span class="string">'𠮷'</span>.at(<span class="number">0</span>) <span class="comment">// "𠮷"</span>
</code></pre>
<p>这个方法可以通过<a href="https://github.com/es-shims/String.prototype.at" target="_blank" rel="external">垫片库</a>实现。</p>
<h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\u004F）和<code>ˇ</code>（\u030C）合成<code>Ǒ</code>（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。</p>
<pre><code class="javascript"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span>

<span class="string">'\u01D1'</span>.length <span class="comment">// 1</span>
<span class="string">'\u004F\u030C'</span>.length <span class="comment">// 2</span>
</code></pre>
<p>上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</p>
<pre><code class="javascript"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()
<span class="comment">// true</span>
</code></pre>
<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>
<ul>
<li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li>
<li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<pre><code class="javascript"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length <span class="comment">// 1</span>
<span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length <span class="comment">// 2</span>
</code></pre>
<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>
<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。</p>
<h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;

s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span>
s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span>
s.includes(<span class="string">'o'</span>) <span class="comment">// true</span>
</code></pre>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;

s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span>
s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span>
s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span>
</code></pre>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<pre><code class="javascript"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span>
<span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span>
<span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span>
</code></pre>
<p>参数如果是小数，会被取整。</p>
<pre><code class="javascript"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span>
</code></pre>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<pre><code class="javascript"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)
<span class="comment">// RangeError</span>
<span class="string">'na'</span>.repeat(<span class="number">-1</span>)
<span class="comment">// RangeError</span>
</code></pre>
<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。</p>
<pre><code class="javascript"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span>
</code></pre>
<p>参数<code>NaN</code>等同于0。</p>
<pre><code class="javascript"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span>
</code></pre>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<pre><code class="javascript"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span>
<span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span>
</code></pre>
<h2 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h2><p>ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart</code>用于头部补全，<code>padEnd</code>用于尾部补全。</p>
<pre><code class="javascript"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span>
<span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span>

<span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span>
<span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span>
</code></pre>
<p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<pre><code class="javascript"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span>
<span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span>
</code></pre>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<pre><code class="javascript"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)
<span class="comment">// '0123456abc'</span>
</code></pre>
<p>如果省略第二个参数，则会用空格补全长度。</p>
<pre><code class="javascript"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span>
<span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span>
</code></pre>
<p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</p>
<pre><code class="javascript"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span>
<span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span>
<span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span>
</code></pre>
<p>另一个用途是提示字符串格式。</p>
<pre><code class="javascript"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span>
<span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span>
</code></pre>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>传统的JavaScript语言，输出模板通常是这样写的。</p>
<pre><code class="javascript">$(<span class="string">'#result'</span>).append(
  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +
  <span class="string">'items in your basket, '</span> +
  <span class="string">'&lt;em&gt;'</span> + basket.onSale +
  <span class="string">'&lt;/em&gt; are on sale!'</span>
);
</code></pre>
<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p>
<pre><code class="javascript">$(<span class="string">'#result'</span>).append(<span class="string">`
  There are &lt;b&gt;<span class="subst">${basket.count}</span>&lt;/b&gt; items
   in your basket, &lt;em&gt;<span class="subst">${basket.onSale}</span>&lt;/em&gt;
  are on sale!
`</span>);
</code></pre>
<p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<pre><code class="javascript"><span class="comment">// 普通字符串</span>
<span class="string">`In JavaScript '\n' is a line-feed.`</span>

<span class="comment">// 多行字符串</span>
<span class="string">`In JavaScript this is
 not legal.`</span>

<span class="built_in">console</span>.log(<span class="string">`string text line 1
string text line 2`</span>);

<span class="comment">// 字符串中嵌入变量</span>
<span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;
<span class="string">`Hello <span class="subst">${name}</span>, how are you <span class="subst">${time}</span>?`</span>
</code></pre>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code class="javascript"><span class="keyword">var</span> greeting = <span class="string">`\`Yo\` World!`</span>;
</code></pre>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<pre><code class="javascript">$(<span class="string">'#list'</span>).html(<span class="string">`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`</span>);
</code></pre>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>
<pre><code class="javascript">$(<span class="string">'#list'</span>).html(<span class="string">`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`</span>.trim());
</code></pre>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>{
  <span class="keyword">if</span> (!user.hasPrivilege(action)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(
      <span class="comment">// 传统写法为</span>
      <span class="comment">// 'User '</span>
      <span class="comment">// + user.name</span>
      <span class="comment">// + ' is not authorized to do '</span>
      <span class="comment">// + action</span>
      <span class="comment">// + '.'</span>
      <span class="string">`User <span class="subst">${user.name}</span> is not authorized to do <span class="subst">${action}</span>.`</span>);
  }
}
</code></pre>
<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p>
<pre><code class="javascript"><span class="keyword">var</span> x = <span class="number">1</span>;
<span class="keyword">var</span> y = <span class="number">2</span>;

<span class="string">`<span class="subst">${x}</span> + <span class="subst">${y}</span> = <span class="subst">${x + y}</span>`</span>
<span class="comment">// "1 + 2 = 3"</span>

<span class="string">`<span class="subst">${x}</span> + <span class="subst">${y * <span class="number">2</span>}</span> = <span class="subst">${x + y * <span class="number">2</span>}</span>`</span>
<span class="comment">// "1 + 4 = 5"</span>

<span class="keyword">var</span> obj = {<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>};
<span class="string">`<span class="subst">${obj.x + obj.y}</span>`</span>
<span class="comment">// 3</span>
</code></pre>
<p>模板字符串之中还能调用函数。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{
  <span class="keyword">return</span> <span class="string">"Hello World"</span>;
}

<span class="string">`foo <span class="subst">${fn()}</span> bar`</span>
<span class="comment">// foo Hello World bar</span>
</code></pre>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<pre><code class="javascript"><span class="comment">// 变量place没有声明</span>
<span class="keyword">var</span> msg = <span class="string">`Hello, <span class="subst">${place}</span>`</span>;
<span class="comment">// 报错</span>
</code></pre>
<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<pre><code class="javascript"><span class="string">`Hello <span class="subst">${<span class="string">'World'</span>}</span>`</span>
<span class="comment">// "Hello World"</span>
</code></pre>
<p>模板字符串甚至还能嵌套。</p>
<pre><code class="javascript"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`
  &lt;table&gt;
  <span class="subst">${addrs.map(addr =&gt; <span class="string">`
    &lt;tr&gt;&lt;td&gt;<span class="subst">${addr.first}</span>&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;<span class="subst">${addr.last}</span>&lt;/td&gt;&lt;/tr&gt;
  `</span>).join(<span class="string">''</span>)}</span>
  &lt;/table&gt;
`</span>;
</code></pre>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>
<pre><code class="javascript"><span class="keyword">const</span> data = [
    { <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> },
    { <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> },
];

<span class="built_in">console</span>.log(tmpl(data));
<span class="comment">// &lt;table&gt;</span>
<span class="comment">//</span>
<span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span>
<span class="comment">//</span>
<span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span>
<span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span class="comment">//</span>
<span class="comment">// &lt;/table&gt;</span>
</code></pre>
<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p>
<pre><code class="javascript"><span class="comment">// 写法一</span>
<span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello ${name}!`'</span>;
<span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);
func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span>

<span class="comment">// 写法二</span>
<span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello ${name}!`'</span>;
<span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);
func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span>
</code></pre>
<h2 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h2><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p>
<pre><code class="javascript"><span class="keyword">var</span> template = <span class="string">`
&lt;ul&gt;
  &lt;% for(var i=0; i &lt; data.supplies.length; i++) { %&gt;
    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
  &lt;% } %&gt;
&lt;/ul&gt;
`</span>;
</code></pre>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置JavaScript代码，使用<code>&lt;%= ... %&gt;</code>输出JavaScript表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为JavaScript表达式字符串。</p>
<pre><code class="javascript">echo(<span class="string">'&lt;ul&gt;'</span>);
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) {
  echo(<span class="string">'&lt;li&gt;'</span>);
  echo(data.supplies[i]);
  echo(<span class="string">'&lt;/li&gt;'</span>);
};
echo(<span class="string">'&lt;/ul&gt;'</span>);
</code></pre>
<p>这个转换使用正则表达式就行了。</p>
<pre><code class="javascript"><span class="keyword">var</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;
<span class="keyword">var</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;

template = template
  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)
  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);

template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;
</code></pre>
<p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p>
<pre><code class="javascript"><span class="keyword">var</span> script =
<span class="string">`(function parse(data){
  var output = "";

  function echo(html){
    output += html;
  }

  <span class="subst">${ template }</span>

  return output;
})`</span>;

<span class="keyword">return</span> script;
</code></pre>
<p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>{
  <span class="keyword">var</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;
  <span class="keyword">var</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;

  template = template
    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)
    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);

  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;

  <span class="keyword">var</span> script =
  <span class="string">`(function parse(data){
    var output = "";

    function echo(html){
      output += html;
    }

    <span class="subst">${ template }</span>

    return output;
  })`</span>;

  <span class="keyword">return</span> script;
}
</code></pre>
<p><code>compile</code>函数的用法如下。</p>
<pre><code class="javascript"><span class="keyword">var</span> parse = <span class="built_in">eval</span>(compile(template));
div.innerHTML = parse({ <span class="attr">supplies</span>: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] });
<span class="comment">//   &lt;ul&gt;</span>
<span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span>
<span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span>
<span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span>
<span class="comment">//   &lt;/ul&gt;</span>
</code></pre>
<h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<pre><code class="javascript">alert<span class="string">`123`</span>
<span class="comment">// 等同于</span>
alert(<span class="number">123</span>)
</code></pre>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<pre><code class="javascript"><span class="keyword">var</span> a = <span class="number">5</span>;
<span class="keyword">var</span> b = <span class="number">10</span>;

tag<span class="string">`Hello <span class="subst">${ a + b }</span> world <span class="subst">${ a * b }</span>`</span>;
<span class="comment">// 等同于</span>
tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);
</code></pre>
<p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>
<p>函数<code>tag</code>依次会接收到多个参数。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>{
  <span class="comment">// ...</span>
}

<span class="comment">// 等同于</span>

<span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>{
  <span class="comment">// ...</span>
}
</code></pre>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>
<p><code>tag</code>函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p>也就是说，<code>tag</code>函数实际上以下面的形式调用。</p>
<pre><code class="javascript">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)
</code></pre>
<p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p>
<pre><code class="javascript"><span class="keyword">var</span> a = <span class="number">5</span>;
<span class="keyword">var</span> b = <span class="number">10</span>;

<span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>{
  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);
  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);
  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);
  <span class="built_in">console</span>.log(v1);
  <span class="built_in">console</span>.log(v2);

  <span class="keyword">return</span> <span class="string">"OK"</span>;
}

tag<span class="string">`Hello <span class="subst">${ a + b }</span> world <span class="subst">${ a * b}</span>`</span>;
<span class="comment">// "Hello "</span>
<span class="comment">// " world "</span>
<span class="comment">// ""</span>
<span class="comment">// 15</span>
<span class="comment">// 50</span>
<span class="comment">// "OK"</span>
</code></pre>
<p>下面是一个更复杂的例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> total = <span class="number">30</span>;
<span class="keyword">var</span> msg = passthru<span class="string">`The total is <span class="subst">${total}</span> (<span class="subst">${total*<span class="number">1.05</span>}</span> with tax)`</span>;

<span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>{
  <span class="keyword">var</span> result = <span class="string">''</span>;
  <span class="keyword">var</span> i = <span class="number">0</span>;

  <span class="keyword">while</span> (i &lt; literals.length) {
    result += literals[i++];
    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) {
      result += <span class="built_in">arguments</span>[i];
    }
  }

  <span class="keyword">return</span> result;
}

msg <span class="comment">// "The total is 30 (31.5 with tax)"</span>
</code></pre>
<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p><code>passthru</code>函数采用rest参数的写法如下。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>{
  <span class="keyword">var</span> output = <span class="string">""</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) {
    output += literals[index] + values[index];
  }

  output += literals[index]
  <span class="keyword">return</span> output;
}
</code></pre>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p>
<pre><code class="javascript"><span class="keyword">var</span> message =
  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">${sender}</span> has sent you a message.&lt;/p&gt;`</span>;

<span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>{
  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) {
    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);

    <span class="comment">// Escape special characters in the substitution.</span>
    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)
            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)
            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);

    <span class="comment">// Don't escape special characters in the template.</span>
    s += templateData[i];
  }
  <span class="keyword">return</span> s;
}
</code></pre>
<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p>
<pre><code class="javascript"><span class="keyword">var</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span>
<span class="keyword">var</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">${sender}</span> has sent you a message.&lt;/p&gt;`</span>;

message
<span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span>
</code></pre>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<pre><code class="javascript">i18n<span class="string">`Welcome to <span class="subst">${siteName}</span>, you are visitor number <span class="subst">${visitorNumber}</span>!`</span>
<span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span>
</code></pre>
<p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>
<pre><code class="javascript"><span class="comment">// 下面的hashTemplate函数</span>
<span class="comment">// 是一个自定义的模板处理函数</span>
<span class="keyword">var</span> libraryHtml = hashTemplate<span class="string">`
  &lt;ul&gt;
    #for book in <span class="subst">${myBooks}</span>
      &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt;
    #end
  &lt;/ul&gt;
`</span>;
</code></pre>
<p>除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。</p>
<pre><code class="javascript">jsx<span class="string">`
  &lt;div&gt;
    &lt;input
      ref='input'
      onChange='<span class="subst">${<span class="keyword">this</span>.handleChange}</span>'
      defaultValue='<span class="subst">${<span class="keyword">this</span>.state.value}</span>' /&gt;
      <span class="subst">${<span class="keyword">this</span>.state.value}</span>
   &lt;/div&gt;
`</span>
</code></pre>
<p>上面的代码通过<code>jsx</code>函数，将一个DOM字符串转为React对象。你可以在Github找到<code>jsx</code>函数的<a href="https://gist.github.com/lygaret/a68220defa69174bdec5" target="_blank" rel="external">具体实现</a>。</p>
<p>下面则是一个假想的例子，通过<code>java</code>函数，在JavaScript代码之中运行Java代码。</p>
<pre><code class="javascript">java<span class="string">`
class HelloWorldApp {
  public static void main(String[] args) {
    System.out.println(“Hello World!”); // Display the string.
  }
}
`</span>
HelloWorldApp.main();
</code></pre>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p>
<pre><code class="javascript"><span class="built_in">console</span>.log<span class="string">`123`</span>
<span class="comment">// ["123", raw: Array[1]]</span>
</code></pre>
<p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。</p>
<pre><code class="javascript">tag<span class="string">`First line\nSecond line`</span>

<span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>{
  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);
  <span class="comment">// "First line\\nSecond line"</span>
}
</code></pre>
<p>上面代码中，<code>tag</code>函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6还为原生的String对象，提供了一个<code>raw</code>方法。</p>
<p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<pre><code class="javascript"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">${<span class="number">2</span>+<span class="number">3</span>}</span>!`</span>;
<span class="comment">// "Hi\\n5!"</span>

<span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;
<span class="comment">// 'Hi\\u000A!'</span>
</code></pre>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。</p>
<pre><code class="javascript"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span>
<span class="comment">// "Hi\\n"</span>
</code></pre>
<p><code>String.raw</code>的代码基本如下。</p>
<pre><code class="javascript"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>{
  <span class="keyword">var</span> output = <span class="string">""</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) {
    output += strings.raw[index] + values[index];
  }

  output += strings.raw[index]
  <span class="keyword">return</span> output;
}
</code></pre>
<p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p>
<pre><code class="javascript"><span class="built_in">String</span>.raw({ <span class="attr">raw</span>: <span class="string">'test'</span> }, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);
<span class="comment">// 't0e1s2t'</span>

<span class="comment">// 等同于</span>
<span class="built_in">String</span>.raw({ <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] }, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);
</code></pre>
<h2 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</p>
<p>举例来说，在标签模板里面可以嵌入Latex语言。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>{
  <span class="comment">// ...</span>
}

<span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`
\newcommand{\fun}{\textbf{Fun!}}  // 正常工作
\newcommand{\unicode}{\textbf{Unicode!}} // 报错
\newcommand{\xerxes}{\textbf{King!}} // 报错

Breve over the h goes \u{h}ere // 报错
`</span>
</code></pre>
<p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于Latex语言来说完全是合法的，但是JavaScript引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将<code>\u00FF</code>和<code>\u{42}</code>当作Unicode字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。</p>
<p>为了解决这个问题，现在有一个<a href="https://tc39.github.io/proposal-template-literal-revision/" target="_blank" rel="external">提案</a>，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>{
  strs[<span class="number">0</span>] === <span class="literal">undefined</span>
  strs.raw[<span class="number">0</span>] === <span class="string">"\\unicode and \\u{55}"</span>;
}
tag<span class="string">`\unicode and \u{55}`</span>
</code></pre>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
<pre><code class="javascript"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>; <span class="comment">// 报错</span>
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 字符串的扩展&lt;br&gt;date: 2016-11-15 15:45:19&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ECMAScript6
- JavaScript
- JS
- ES6
- Unicode
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/set-map/"/>
    <id>http://ecut.club/2017/04/19/set-map/</id>
    <published>2017-04-19T00:24:13.756Z</published>
    <updated>2017-01-12T08:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Set和Map数据结构<br>date: 2017-01-05 11:40:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JS
- ES6
- Set
- Map
</code></pre><hr>
<h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成Set数据结构。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();

[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));

<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) {
  <span class="built_in">console</span>.log(i);
}
<span class="comment">// 2 3 5 4</span>
</code></pre>
<p>上面代码通过<code>add</code>方法向Set结构加入成员，结果表明Set结构不会添加重复的值。</p>
<p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>
<pre><code class="javascript"><span class="comment">// 例一</span>
<span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);
[...set]
<span class="comment">// [1, 2, 3, 4]</span>

<span class="comment">// 例二</span>
<span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);
items.size <span class="comment">// 5</span>

<span class="comment">// 例三</span>
<span class="function"><span class="keyword">function</span> <span class="title">divs</span> (<span class="params"></span>) </span>{
  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">'div'</span>)];
}

<span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(divs());
set.size <span class="comment">// 56</span>

<span class="comment">// 类似于</span>
divs().forEach(<span class="function"><span class="params">div</span> =&gt;</span> set.add(div));
set.size <span class="comment">// 56</span>
</code></pre>
<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>
<p>上面代码中，也展示了一种去除数组重复成员的方法。</p>
<pre><code class="javascript"><span class="comment">// 去除数组的重复成员</span>
[...new <span class="built_in">Set</span>(array)]
</code></pre>
<p>向Set加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();
<span class="keyword">let</span> a = <span class="literal">NaN</span>;
<span class="keyword">let</span> b = <span class="literal">NaN</span>;
set.add(a);
set.add(b);
set <span class="comment">// Set {NaN}</span>
</code></pre>
<p>上面代码向Set实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在Set内部，两个<code>NaN</code>是相等。</p>
<p>另外，两个对象总是不相等的。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();

set.add({});
set.size <span class="comment">// 1</span>

set.add({});
set.size <span class="comment">// 2</span>
</code></pre>
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
<h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h3><p>Set结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>上面这些属性和方法的实例如下。</p>
<pre><code class="javascript">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);
<span class="comment">// 注意2被加入了两次</span>

s.size <span class="comment">// 2</span>

s.has(<span class="number">1</span>) <span class="comment">// true</span>
s.has(<span class="number">2</span>) <span class="comment">// true</span>
s.has(<span class="number">3</span>) <span class="comment">// false</span>

s.delete(<span class="number">2</span>);
s.has(<span class="number">2</span>) <span class="comment">// false</span>
</code></pre>
<p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>
<pre><code class="javascript"><span class="comment">// 对象的写法</span>
<span class="keyword">var</span> properties = {
  <span class="string">'width'</span>: <span class="number">1</span>,
  <span class="string">'height'</span>: <span class="number">1</span>
};

<span class="keyword">if</span> (properties[someName]) {
  <span class="comment">// do something</span>
}

<span class="comment">// Set的写法</span>
<span class="keyword">var</span> properties = <span class="keyword">new</span> <span class="built_in">Set</span>();

properties.add(<span class="string">'width'</span>);
properties.add(<span class="string">'height'</span>);

<span class="keyword">if</span> (properties.has(someName)) {
  <span class="comment">// do something</span>
}
</code></pre>
<p><code>Array.from</code>方法可以将Set结构转为数组。</p>
<pre><code class="javascript"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="keyword">var</span> array = <span class="built_in">Array</span>.from(items);
</code></pre>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>{
  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));
}

dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span>
</code></pre>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);

<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) {
  <span class="built_in">console</span>.log(item);
}
<span class="comment">// red</span>
<span class="comment">// green</span>
<span class="comment">// blue</span>

<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) {
  <span class="built_in">console</span>.log(item);
}
<span class="comment">// red</span>
<span class="comment">// green</span>
<span class="comment">// blue</span>

<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) {
  <span class="built_in">console</span>.log(item);
}
<span class="comment">// ["red", "red"]</span>
<span class="comment">// ["green", "green"]</span>
<span class="comment">// ["blue", "blue"]</span>
</code></pre>
<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<pre><code class="javascript"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values
<span class="comment">// true</span>
</code></pre>
<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历Set。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);

<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) {
  <span class="built_in">console</span>.log(x);
}
<span class="comment">// red</span>
<span class="comment">// green</span>
<span class="comment">// blue</span>
</code></pre>
<p><strong>（2）<code>forEach()</code></strong></p>
<p>Set结构的实例的<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(value * <span class="number">2</span>) )
<span class="comment">// 2</span>
<span class="comment">// 4</span>
<span class="comment">// 6</span>
</code></pre>
<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，<code>forEach</code>方法还可以有第二个参数，表示绑定的this对象。</p>
<p><strong>（3）遍历的应用</strong></p>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于Set结构。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);
<span class="keyword">let</span> arr = [...set];
<span class="comment">// ['red', 'green', 'blue']</span>
</code></pre>
<p>扩展运算符和Set结构相结合，就可以去除数组的重复成员。</p>
<pre><code class="javascript"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];
<span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];
<span class="comment">// [3, 5, 2]</span>
</code></pre>
<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以用于Set了。</p>
<pre><code class="javascript"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));
<span class="comment">// 返回Set结构：{2, 4, 6}</span>

<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));
<span class="comment">// 返回Set结构：{2, 4}</span>
</code></pre>
<p>因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<pre><code class="javascript"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);

<span class="comment">// 并集</span>
<span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);
<span class="comment">// Set {1, 2, 3, 4}</span>

<span class="comment">// 交集</span>
<span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));
<span class="comment">// set {2, 3}</span>

<span class="comment">// 差集</span>
<span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));
<span class="comment">// Set {1}</span>
</code></pre>
<p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用<code>Array.from</code>方法。</p>
<pre><code class="javascript"><span class="comment">// 方法一</span>
<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));
<span class="comment">// set的值是2, 4, 6</span>

<span class="comment">// 方法二</span>
<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, val =&gt; val * <span class="number">2</span>));
<span class="comment">// set的值是2, 4, 6</span>
</code></pre>
<p>上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。</p>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<pre><code class="javascript"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();
ws.add(<span class="number">1</span>)
<span class="comment">// TypeError: Invalid value used in weak set</span>
ws.add(<span class="built_in">Symbol</span>())
<span class="comment">// TypeError: invalid value used in weak set</span>
</code></pre>
<p>上面代码试图向WeakSet添加一个数值和<code>Symbol</code>值，结果报错，因为WeakSet只能放置对象。</p>
<p>WeakSet是一个构造函数，可以使用<code>new</code>命令，创建WeakSet数据结构。</p>
<pre><code class="javascript"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();
</code></pre>
<p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。</p>
<pre><code class="javascript"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]];
<span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);
</code></pre>
<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为WeakSet构造函数的参数，<code>a</code>的成员会自动成为WeakSet的成员。</p>
<p>注意，是<code>a</code>数组的成员成为WeakSet的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>
<pre><code class="javascript"><span class="keyword">var</span> b = [<span class="number">3</span>, <span class="number">4</span>];
<span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b);
<span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span>
</code></pre>
<p>上面代码中，数组<code>b</code>的成员不是对象，加入WeaKSet就会报错。</p>
<p>WeakSet结构有以下三个方法。</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向WeakSet实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除WeakSet实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();
<span class="keyword">var</span> obj = {};
<span class="keyword">var</span> foo = {};

ws.add(<span class="built_in">window</span>);
ws.add(obj);

ws.has(<span class="built_in">window</span>); <span class="comment">// true</span>
ws.has(foo);    <span class="comment">// false</span>

ws.delete(<span class="built_in">window</span>);
ws.has(<span class="built_in">window</span>);    <span class="comment">// false</span>
</code></pre>
<p>WeakSet没有<code>size</code>属性，没有办法遍历它的成员。</p>
<pre><code class="javascript">ws.size <span class="comment">// undefined</span>
ws.forEach <span class="comment">// undefined</span>

ws.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>{ <span class="built_in">console</span>.log(<span class="string">'WeakSet has '</span> + item)})
<span class="comment">// TypeError: undefined is not a function</span>
</code></pre>
<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>
<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<p>下面是WeakSet的另一个例子。</p>
<pre><code class="javascript"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()
<span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{
  <span class="keyword">constructor</span>() {
    foos.add(<span class="keyword">this</span>)
  }
  method () {
    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);
    }
  }
}
</code></pre>
<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用WeakSet的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map结构的目的和基本用法"><a href="#Map结构的目的和基本用法" class="headerlink" title="Map结构的目的和基本用法"></a>Map结构的目的和基本用法</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<pre><code class="javascript"><span class="keyword">var</span> data = {};
<span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);

data[element] = <span class="string">'metadata'</span>;
data[<span class="string">'[object HTMLDivElement]'</span>] <span class="comment">// "metadata"</span>
</code></pre>
<p>上面代码原意是将一个DOM节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>
<p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();
<span class="keyword">var</span> o = {<span class="attr">p</span>: <span class="string">'Hello World'</span>};

m.set(o, <span class="string">'content'</span>)
m.get(o) <span class="comment">// "content"</span>

m.has(o) <span class="comment">// true</span>
m.delete(o) <span class="comment">// true</span>
m.has(o) <span class="comment">// false</span>
</code></pre>
<p>上面代码使用<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>
<p>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<pre><code class="javascript"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([
  [<span class="string">'name'</span>, <span class="string">'张三'</span>],
  [<span class="string">'title'</span>, <span class="string">'Author'</span>]
]);

map.size <span class="comment">// 2</span>
map.has(<span class="string">'name'</span>) <span class="comment">// true</span>
map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span>
map.has(<span class="string">'title'</span>) <span class="comment">// true</span>
map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span>
</code></pre>
<p>上面代码在新建Map实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>
<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<pre><code class="javascript"><span class="keyword">var</span> items = [
  [<span class="string">'name'</span>, <span class="string">'张三'</span>],
  [<span class="string">'title'</span>, <span class="string">'Author'</span>]
];
<span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();
items.forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.set(key, value));
</code></pre>
<p>下面的例子中，字符串<code>true</code>和布尔值<code>true</code>是两个不同的键。</p>
<pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([
  [<span class="literal">true</span>, <span class="string">'foo'</span>],
  [<span class="string">'true'</span>, <span class="string">'bar'</span>]
]);

m.get(<span class="literal">true</span>) <span class="comment">// 'foo'</span>
m.get(<span class="string">'true'</span>) <span class="comment">// 'bar'</span>
</code></pre>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();

map
.set(<span class="number">1</span>, <span class="string">'aaa'</span>)
.set(<span class="number">1</span>, <span class="string">'bbb'</span>);

map.get(<span class="number">1</span>) <span class="comment">// "bbb"</span>
</code></pre>
<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<pre><code class="javascript"><span class="keyword">new</span> <span class="built_in">Map</span>().get(<span class="string">'asfddfsasadf'</span>)
<span class="comment">// undefined</span>
</code></pre>
<p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>
<pre><code class="javascript"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();

map.set([<span class="string">'a'</span>], <span class="number">555</span>);
map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span>
</code></pre>
<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p>
<pre><code class="javascript"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();

<span class="keyword">var</span> k1 = [<span class="string">'a'</span>];
<span class="keyword">var</span> k2 = [<span class="string">'a'</span>];

map
.set(k1, <span class="number">111</span>)
.set(k2, <span class="number">222</span>);

map.get(k1) <span class="comment">// 111</span>
map.get(k2) <span class="comment">// 222</span>
</code></pre>
<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在Map结构中被视为两个键。</p>
<p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括<code>0</code>和<code>-0</code>。另外，虽然<code>NaN</code>不严格相等于自身，但Map将其视为同一个键。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();

map.set(<span class="literal">NaN</span>, <span class="number">123</span>);
map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span>

map.set(<span class="number">-0</span>, <span class="number">123</span>);
map.get(+<span class="number">0</span>) <span class="comment">// 123</span>
</code></pre>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size属性</strong></p>
<p><code>size</code>属性返回Map结构的成员总数。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();
map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);
map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);

map.size <span class="comment">// 2</span>
</code></pre>
<p><strong>（2）set(key, value)</strong></p>
<p><code>set</code>方法设置<code>key</code>所对应的键值，然后返回整个Map结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();

m.set(<span class="string">"edition"</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span>
m.set(<span class="number">262</span>, <span class="string">"standard"</span>)     <span class="comment">// 键是数值</span>
m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>)    <span class="comment">// 键是undefined</span>
</code></pre>
<p><code>set</code>方法返回的是Map本身，因此可以采用链式写法。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()
  .set(<span class="number">1</span>, <span class="string">'a'</span>)
  .set(<span class="number">2</span>, <span class="string">'b'</span>)
  .set(<span class="number">3</span>, <span class="string">'c'</span>);
</code></pre>
<p><strong>（3）get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();

<span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{<span class="built_in">console</span>.log(<span class="string">"hello"</span>);}
m.set(hello, <span class="string">"Hello ES6!"</span>) <span class="comment">// 键是函数</span>

m.get(hello)  <span class="comment">// Hello ES6!</span>
</code></pre>
<p><strong>（4）has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>
<pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();

m.set(<span class="string">"edition"</span>, <span class="number">6</span>);
m.set(<span class="number">262</span>, <span class="string">"standard"</span>);
m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>);

m.has(<span class="string">"edition"</span>)     <span class="comment">// true</span>
m.has(<span class="string">"years"</span>)       <span class="comment">// false</span>
m.has(<span class="number">262</span>)           <span class="comment">// true</span>
m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span>
</code></pre>
<p><strong>（5）delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回true。如果删除失败，返回false。</p>
<pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();
m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>);
m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span>

m.delete(<span class="literal">undefined</span>)
m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span>
</code></pre>
<p><strong>（6）clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();
map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);
map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);

map.size <span class="comment">// 2</span>
map.clear()
map.size <span class="comment">// 0</span>
</code></pre>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器。</li>
<li><code>values()</code>：返回键值的遍历器。</li>
<li><code>entries()</code>：返回所有成员的遍历器。</li>
<li><code>forEach()</code>：遍历Map的所有成员。</li>
</ul>
<p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p>
<p>下面是使用实例。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([
  [<span class="string">'F'</span>, <span class="string">'no'</span>],
  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],
]);

<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) {
  <span class="built_in">console</span>.log(key);
}
<span class="comment">// "F"</span>
<span class="comment">// "T"</span>

<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) {
  <span class="built_in">console</span>.log(value);
}
<span class="comment">// "no"</span>
<span class="comment">// "yes"</span>

<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) {
  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);
}
<span class="comment">// "F" "no"</span>
<span class="comment">// "T" "yes"</span>

<span class="comment">// 或者</span>
<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) {
  <span class="built_in">console</span>.log(key, value);
}

<span class="comment">// 等同于使用map.entries()</span>
<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) {
  <span class="built_in">console</span>.log(key, value);
}
</code></pre>
<p>上面代码最后的那个例子，表示Map结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<pre><code class="javascript">map[<span class="built_in">Symbol</span>.iterator] === map.entries
<span class="comment">// true</span>
</code></pre>
<p>Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（<code>...</code>）。</p>
<pre><code class="javascript"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([
  [<span class="number">1</span>, <span class="string">'one'</span>],
  [<span class="number">2</span>, <span class="string">'two'</span>],
  [<span class="number">3</span>, <span class="string">'three'</span>],
]);

[...map.keys()]
<span class="comment">// [1, 2, 3]</span>

[...map.values()]
<span class="comment">// ['one', 'two', 'three']</span>

[...map.entries()]
<span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span>

[...map]
<span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span>
</code></pre>
<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现Map的遍历和过滤（Map本身没有<code>map</code>和<code>filter</code>方法）。</p>
<pre><code class="javascript"><span class="keyword">let</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()
  .set(<span class="number">1</span>, <span class="string">'a'</span>)
  .set(<span class="number">2</span>, <span class="string">'b'</span>)
  .set(<span class="number">3</span>, <span class="string">'c'</span>);

<span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(
  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)
);
<span class="comment">// 产生Map结构 {1 =&gt; 'a', 2 =&gt; 'b'}</span>

<span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(
  [...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">'_'</span> + v])
    );
<span class="comment">// 产生Map结构 {2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'}</span>
</code></pre>
<p>此外，Map还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>
<pre><code class="javascript">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);
});
</code></pre>
<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> reporter = {
  <span class="attr">report</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);
  }
};

map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>{
  <span class="keyword">this</span>.report(key, value);
}, reporter);
</code></pre>
<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map转为数组</strong></p>
<p>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>
<pre><code class="javascript"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set({<span class="attr">foo</span>: <span class="number">3</span>}, [<span class="string">'abc'</span>]);
[...myMap]
<span class="comment">// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]</span>
</code></pre>
<p><strong>（2）数组转为Map</strong></p>
<p>将数组转入Map构造函数，就可以转为Map。</p>
<pre><code class="javascript"><span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">true</span>, <span class="number">7</span>], [{<span class="attr">foo</span>: <span class="number">3</span>}, [<span class="string">'abc'</span>]]])
<span class="comment">// Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']}</span>
</code></pre>
<p><strong>（3）Map转为对象</strong></p>
<p>如果所有Map的键都是字符串，它可以转为对象。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>{
  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);
  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) {
    obj[k] = v;
  }
  <span class="keyword">return</span> obj;
}

<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);
strMapToObj(myMap)
<span class="comment">// { yes: true, no: false }</span>
</code></pre>
<p><strong>（4）对象转为Map</strong></p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>{
  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();
  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  <span class="keyword">return</span> strMap;
}

objToStrMap({<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>})
<span class="comment">// [ [ 'yes', true ], [ 'no', false ] ]</span>
</code></pre>
<p><strong>（5）Map转为JSON</strong></p>
<p>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>{
  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));
}

<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);
strMapToJson(myMap)
<span class="comment">// '{"yes":true,"no":false}'</span>
</code></pre>
<p>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>{
  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);
}

<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set({<span class="attr">foo</span>: <span class="number">3</span>}, [<span class="string">'abc'</span>]);
mapToArrayJson(myMap)
<span class="comment">// '[[true,7],[{"foo":3},["abc"]]]'</span>
</code></pre>
<p><strong>（6）JSON转为Map</strong></p>
<p>JSON转为Map，正常情况下，所有键名都是字符串。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>{
  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));
}

jsonToStrMap(<span class="string">'{"yes":true,"no":false}'</span>)
<span class="comment">// Map {'yes' =&gt; true, 'no' =&gt; false}</span>
</code></pre>
<p>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>{
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));
}

jsonToMap(<span class="string">'[[true,7],[{"foo":3},["abc"]]]'</span>)
<span class="comment">// Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']}</span>
</code></pre>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><code>WeakMap</code>结构与<code>Map</code>结构基本类似，唯一的区别是它只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
<pre><code class="javascript"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()
map.set(<span class="number">1</span>, <span class="number">2</span>)
<span class="comment">// TypeError: 1 is not an object!</span>
map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)
<span class="comment">// TypeError: Invalid value used as weak map key</span>
</code></pre>
<p>上面代码中，如果将<code>1</code>和<code>Symbol</code>作为WeakMap的键名，都会报错。</p>
<p><code>WeakMap</code>的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，<code>WeakMap</code>自动移除对应的键值对。典型应用是，一个对应DOM元素的<code>WeakMap</code>结构，当某个DOM元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。基本上，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>下面是<code>WeakMap</code>结构的一个例子，可以看到用法上与<code>Map</code>几乎一样。</p>
<pre><code class="javascript"><span class="keyword">var</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();
<span class="keyword">var</span> element = <span class="built_in">document</span>.querySelector(<span class="string">".element"</span>);

wm.set(element, <span class="string">"Original"</span>);
wm.get(element) <span class="comment">// "Original"</span>

element.parentNode.removeChild(element);
element = <span class="literal">null</span>;
wm.get(element) <span class="comment">// undefined</span>
</code></pre>
<p>上面代码中，变量<code>wm</code>是一个<code>WeakMap</code>实例，我们将一个<code>DOM</code>节点<code>element</code>作为键名，然后销毁这个节点，<code>element</code>对应的键就自动消失了，再引用这个键名就返回<code>undefined</code>。</p>
<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有<code>key()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性；二是无法清空，即不支持<code>clear</code>方法。这与<code>WeakMap</code>的键不被计入引用、被垃圾回收机制忽略有关。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();

wm.size
<span class="comment">// undefined</span>

wm.forEach
<span class="comment">// undefined</span>
</code></pre>
<p>前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);
<span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();

myWeakmap.set(myElement, {<span class="attr">timesClicked</span>: <span class="number">0</span>});

myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);
  logoData.timesClicked++;
}, <span class="literal">false</span>);
</code></pre>
<p>上面代码中，<code>myElement</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是<code>myElement</code>。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<pre><code class="javascript"><span class="keyword">let</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();
<span class="keyword">let</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();

<span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>{
  <span class="keyword">constructor</span>(counter, action) {
    _counter.set(<span class="keyword">this</span>, counter);
    _action.set(<span class="keyword">this</span>, action);
  }
  dec() {
    <span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);
    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;
    counter--;
    _counter.set(<span class="keyword">this</span>, counter);
    <span class="keyword">if</span> (counter === <span class="number">0</span>) {
      _action.get(<span class="keyword">this</span>)();
    }
  }
}

<span class="keyword">let</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));

c.dec()
c.dec()
<span class="comment">// DONE</span>
</code></pre>
<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Set和Map数据结构&lt;br&gt;date: 2017-01-05 11:40:19&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ECMAScript6
- JavaScript
- JS
- ES6
- Set
- Map
&lt;/code&gt;&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/select-plugin/"/>
    <id>http://ecut.club/2017/04/19/select-plugin/</id>
    <published>2017-04-19T00:24:13.741Z</published>
    <updated>2017-03-31T08:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 三级联动的生成器插件<br>date: 2017-03-12 17:03:01<br>tags:</p>
<ul>
<li>ES6</li>
<li>ECMAScript6</li>
<li>JS</li>
<li>JavaScript</li>
<li>npm</li>
</ul>
<hr>
<h1 id="三级联动的生成器插件"><a href="#三级联动的生成器插件" class="headerlink" title="三级联动的生成器插件"></a>三级联动的生成器插件</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个三级联动的生成器插件，默认生成中国地区🇨🇳的三级联动数据，也可以自定义数据。<br>npm地址：<a href="https://www.npmjs.com/package/select-plugin" target="_blank" rel="external">https://www.npmjs.com/package/select-plugin</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>输入 <code>npm install select-plugin</code> .  </p>
<p>最好先初始化一下package.json文件，输入 <code>npm init -y</code>，然后再执行安装<code>npm install select-plugin</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="默认数据"><a href="#默认数据" class="headerlink" title="默认数据"></a><strong>默认数据</strong></h3><p> 引入js文件。<br> 在html文件中插入<code>&lt;script src=&quot;./node_modules/select-plugin/dist/select-plugin-all.js&quot;&gt;&lt;/script&gt;</code>，<br> 然后<br> <code>&lt;script&gt;new Select()&lt;/script&gt;</code><br> 默认就可以生成中国地区的三级联动数据啦😄</p>
<h3 id="自定义数据"><a href="#自定义数据" class="headerlink" title="自定义数据"></a><strong>自定义数据</strong></h3><p>如果你<strong>只使用</strong>自定义的数据，建议只引入不包含地区数据的js文件，<br>即<code>&lt;script src=&quot;./node_modules/select-plugin/dist/select-plugin.js&quot;&gt;&lt;/script&gt;</code>，<br>这样文件大小可以减少很多，毕竟大中国地区数据太庞大了😇但是务必传递传递相关参数！<br><br><code>new Select(&#39;.container&#39;, data, id, text);</code> <br><br><strong>参数依次是插入父容器位置（默认是body，参数是CSS3选择器的形式，如’#id’ , ‘ .className’），数据，在DOM元素的id，显示的文本</strong></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="html"><span class="meta">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>
<span class="tag">&lt;<span class="name">head</span>&gt;</span>
  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">title</span>&gt;</span>三级联动生成器插件<span class="tag">&lt;/<span class="name">title</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span>
<span class="tag">&lt;<span class="name">body</span>&gt;</span>
  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>

  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/select-plugin/dist/select-plugin-all.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">
  <span class="comment">// 不传任何参数,默认生成中国地区三级联动</span>
    <span class="keyword">new</span> Select();

  <span class="comment">// 自定义数据</span>
    <span class="keyword">var</span> data = {
                <span class="attr">One</span>: [<span class="string">'a1'</span>, <span class="string">'a2'</span>, <span class="string">'a3'</span>],
                <span class="attr">Two</span>: [
                  [<span class="string">'a11'</span>, <span class="string">'a12'</span>, <span class="string">'a13'</span>],
                  [<span class="string">'a21'</span>, <span class="string">'a22'</span>],
                  [<span class="string">'a31'</span>, <span class="string">'a32'</span>]
                ],
                <span class="attr">Three</span>:  [
                  [[<span class="string">'a111'</span>, <span class="string">'a112'</span>], [<span class="string">'a121'</span>, <span class="string">'a122'</span>], [<span class="string">'a131'</span>, <span class="string">'a132'</span>]],
                  [[<span class="string">'a211'</span>, <span class="string">'a212'</span>], [<span class="string">'a221'</span>, <span class="string">'a222'</span>]],
                  [[<span class="string">'a311'</span>], [<span class="string">'a312'</span>]]
                ]
              };
    <span class="keyword">var</span> id = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];
    <span class="keyword">var</span> text = [<span class="string">'选项1'</span>, <span class="string">'选项2'</span>, <span class="string">'选项3'</span>];
    <span class="comment">// 参数依次是插入父容器位置，数据，DOM的id，显示的文本</span>
    <span class="keyword">new</span> Select(<span class="string">'.container'</span>, data, id, text);
  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span>
</code></pre>
<h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="https://icdn.microzz.com/20170312_select_plugin/preview.png" alt="select-plugin-microzz.com"></p>
<h3 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h3><p><a href="https://microzz.github.io/select-plugin/" target="_blank" rel="external">在线预览地址1</a><br><a href="http://microzz.cn/select-plugin/" target="_blank" rel="external">在线预览地址2</a></p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>GitHub： <a href="https://github.com/microzz" target="_blank" rel="external">https://github.com/microzz</a>  <br><br>个人网站：<a href="https://microzz.com/" target="_blank" rel="external">https://microzz.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 三级联动的生成器插件&lt;br&gt;date: 2017-03-12 17:03:01&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES6&lt;/li&gt;
&lt;li&gt;ECMAScript6&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/sass/"/>
    <id>http://ecut.club/2017/04/19/sass/</id>
    <published>2017-04-19T00:24:13.741Z</published>
    <updated>2017-03-18T15:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: SASS用法指南<br>date: 2017-03-18 23:17:32<br>tags:</p>
<ul>
<li>SASS</li>
<li>SCSS</li>
<li>CSS</li>
</ul>
<hr>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;学过CSS的人都知道，它不是一种编程语言。<br>&nbsp;&nbsp;&nbsp;&nbsp;你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;各种”CSS预处理器”之中，我自己最喜欢SASS，觉得它有很多优点，打算以后都用它来写CSS。下面是我整理的用法总结，供自己开发时参考，相信对其他人也有用。</p>
</blockquote>
<h1 id="SASS用法指南"><a href="#SASS用法指南" class="headerlink" title="SASS用法指南"></a>SASS用法指南</h1><p>作者：阮一峰</p>
<h2 id="一、什么是SASS"><a href="#一、什么是SASS" class="headerlink" title="一、什么是SASS"></a>一、什么是SASS</h2><p>SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。<br>本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。</p>
<h2 id="二、安装和使用"><a href="#二、安装和使用" class="headerlink" title="二、安装和使用"></a>二、安装和使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。<br>假定你已经安装好了Ruby，接着在命令行输入下面的命令：<br>　　<code>gem install sass</code><br>然后，就可以使用了。</p>
<h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p>SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。<br>下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。）<br>　　<code>sass test.scss</code><br>如果要将显示结果保存成文件，后面再跟一个.css文件名。<br>　　<code>sass test.scss test.css</code><br>SASS提供四个编译风格的选项：<br>　　<em> <code>nested</code>：嵌套缩进的css代码，它是默认值。
　　</em> <code>expanded</code>：没有缩进的、扩展的css代码。<br>　　<em> <code>compact</code>：简洁格式的css代码。
　　</em> <code>compressed</code>：压缩后的css代码。<br>生产环境当中，一般使用最后一个选项。<br>　　<code>sass --style compressed test.sass test.css</code><br>你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。</p>
<p>　　// watch a file<br>　　<code>sass --watch input.scss:output.css</code><br>　　<br>　　// watch a directory<br>　　<code>sass --watch app/sass:public/stylesheets</code><br>　　<br>SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。</p>
<h2 id="三、基本用法"><a href="#三、基本用法" class="headerlink" title="三、基本用法"></a>三、基本用法</h2><h3 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h3><p>SASS允许使用变量，所有变量以$开头。</p>
<pre><code class="scss">　　<span class="variable">$blue</span> : <span class="number">#1875e7</span>;　
　　<span class="selector-tag">div</span> {
　　　<span class="attribute">color</span> : <span class="variable">$blue</span>;
　　}
</code></pre>
<p>　　<br>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</p>
<pre><code class="scss">　　<span class="variable">$side</span> : left;
　　<span class="selector-class">.rounded</span> {
　　　　<span class="attribute">border</span>-#{<span class="variable">$side</span>}-radius: <span class="number">5px</span>;
　　}
</code></pre>
<h3 id="3-2-计算功能"><a href="#3-2-计算功能" class="headerlink" title="3.2 计算功能"></a>3.2 计算功能</h3><p>SASS允许在代码中使用算式：</p>
<pre><code class="scss">　　<span class="selector-tag">body</span> {
　　　　<span class="attribute">margin</span>: (<span class="number">14px</span>/<span class="number">2</span>);
　　　　<span class="attribute">top</span>: <span class="number">50px</span> + <span class="number">100px</span>;
　　　　<span class="attribute">right</span>: <span class="variable">$var</span> * <span class="number">10%</span>;
　　}
</code></pre>
<h3 id="3-3-嵌套"><a href="#3-3-嵌套" class="headerlink" title="3.3 嵌套"></a>3.3 嵌套</h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p>
<pre><code class="scss">　　<span class="selector-tag">div</span> <span class="selector-tag">h1</span> {
　　　　<span class="attribute">color</span> : red;
　　}
</code></pre>
<p>可以写成：</p>
<pre><code class="scss">　　<span class="selector-tag">div</span> {
　　　　hi {
　　　　　　<span class="attribute">color</span>:red;
　　　　}
　　}
</code></pre>
<p>属性也可以嵌套，比如<code>border-color</code>属性，可以写成：</p>
<pre><code class="scss">　　<span class="selector-tag">p</span> {
　　　　<span class="attribute">border</span>: {
　　　　　　color: red;
　　　　}
　　}
</code></pre>
<p>注意，<code>border</code>后面必须加上冒号。<br>在嵌套的代码块内，可以使用&amp;引用父元素。比如<code>a:hover</code>伪类，可以写成：</p>
<pre><code class="scss">　　<span class="selector-tag">a</span> {
　　　　&amp;:hover { <span class="attribute">color</span>: <span class="number">#ffb3ff</span>; }
　　}
</code></pre>
<h3 id="3-4-注释"><a href="#3-4-注释" class="headerlink" title="3.4 注释"></a>3.4 注释</h3><p>SASS共有两种注释风格。<br>标准的CSS注释 <code>/* comment */</code>，会保留到编译后的文件。<br>单行注释 <code>// comment</code>，只保留在SASS源文件中，编译后被省略。<br>在<code>/*</code>后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p>
<pre><code class="scss">　　<span class="comment">/*! 
　　　　重要注释！
　　*/</span>
</code></pre>
<h2 id="四、代码的重用"><a href="#四、代码的重用" class="headerlink" title="四、代码的重用"></a>四、代码的重用</h2><h3 id="4-1-继承"><a href="#4-1-继承" class="headerlink" title="4.1 继承"></a>4.1 继承</h3><p>SASS允许一个选择器，继承另一个选择器。比如，现有class1：</p>
<pre><code class="scss">　　<span class="selector-class">.class1</span> {
　　　　<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;
　　}
</code></pre>
<p>class2要继承class1，就要使用<code>@extend</code>命令：</p>
<pre><code class="scss">　　<span class="selector-class">.class2</span> {
　　　　@<span class="keyword">extend</span> .class1;
　　　　<span class="attribute">font-size</span>:<span class="number">120%</span>;
　　}
</code></pre>
<h3 id="4-2-Mixin"><a href="#4-2-Mixin" class="headerlink" title="4.2 Mixin"></a>4.2 Mixin</h3><p>Mixin有点像C语言的宏（macro），是可以重用的代码块。<br>使用<code>@mixin</code>命令，定义一个代码块。</p>
<pre><code class="scss">　　@<span class="keyword">mixin</span> left {
　　　　<span class="attribute">float</span>: left;
　　　　<span class="attribute">margin-left</span>: <span class="number">10px</span>;
　　}
</code></pre>
<p>使用<code>@include</code>命令，调用这个mixin。</p>
<pre><code class="scss">　　<span class="selector-tag">div</span> {
　　　　@<span class="keyword">include</span> left;
　　}
</code></pre>
<p>mixin的强大之处，在于可以指定参数和缺省值。</p>
<pre><code class="scss">　　@<span class="keyword">mixin</span> left(<span class="variable">$value</span>: 10px) {
　　　　<span class="attribute">float</span>: left;
　　　　<span class="attribute">margin-right</span>: <span class="variable">$value</span>;
　　}
</code></pre>
<p>使用的时候，根据需要加入参数：</p>
<pre><code class="scss">　　<span class="selector-tag">div</span> {
　　　　@<span class="keyword">include</span> left(<span class="number">20px</span>);
　　}
</code></pre>
<p>下面是一个mixin的实例，用来生成浏览器前缀。</p>
<pre><code class="scss">　　@<span class="keyword">mixin</span> rounded(<span class="variable">$vert</span>, <span class="variable">$horz</span>, <span class="variable">$radius</span>: 10px) {
　　　　<span class="attribute">border</span>-#{<span class="variable">$vert</span>}-#{<span class="variable">$horz</span>}-radius: <span class="variable">$radius</span>;
　　　　-moz-<span class="attribute">border-radius</span>-#{<span class="variable">$vert</span>}#{<span class="variable">$horz</span>}: <span class="variable">$radius</span>;
　　　　-webkit-<span class="attribute">border</span>-#{<span class="variable">$vert</span>}-#{<span class="variable">$horz</span>}-radius: <span class="variable">$radius</span>;
　　}
</code></pre>
<p>使用的时候，可以像下面这样调用：</p>
<pre><code class="scss">　　<span class="selector-id">#navbar</span> <span class="selector-tag">li</span> { @<span class="keyword">include</span> rounded(top, left); }
　　<span class="selector-id">#footer</span> { @<span class="keyword">include</span> rounded(top, left, 5px); }
</code></pre>
<h3 id="4-3-颜色函数"><a href="#4-3-颜色函数" class="headerlink" title="4.3 颜色函数"></a>4.3 颜色函数</h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<pre><code class="scss">　　lighten(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #d6d65c</span>
　　darken(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #a3a329</span>
　　grayscale(<span class="selector-id">#cc3</span>) <span class="comment">// #808080</span>
　　complement(<span class="selector-id">#cc3</span>) <span class="comment">// #33c</span>
</code></pre>
<h3 id="4-4-插入文件"><a href="#4-4-插入文件" class="headerlink" title="4.4 插入文件"></a>4.4 插入文件</h3><p><code>@import</code>命令，用来插入外部文件。<br>　　<code>@import &quot;path/filename.scss&quot;;</code><br>如果插入的是.css文件，则等同于css的import命令。<br>　　<code>@import &quot;foo.css&quot;;</code>
　　</p>
<h2 id="五、高级用法"><a href="#五、高级用法" class="headerlink" title="五、高级用法"></a>五、高级用法</h2><h3 id="5-1-条件语句"><a href="#5-1-条件语句" class="headerlink" title="5.1 条件语句"></a>5.1 条件语句</h3><p><code>@if</code>可以用来判断：</p>
<pre><code class="scss">　　<span class="selector-tag">p</span> {
　　　　@<span class="keyword">if</span> 1 + 1 == 2 { <span class="attribute">border</span>: <span class="number">1px</span> solid; }
　　　　@<span class="keyword">if</span> 5 &lt; 3 { <span class="attribute">border</span>: <span class="number">2px</span> dotted; }
　　}
</code></pre>
<p>配套的还有<code>@else</code>命令：</p>
<pre><code class="scss">　　@<span class="keyword">if</span> lightness(<span class="variable">$color</span>) &gt; 30% {
　　　　<span class="attribute">background-color</span>: <span class="number">#000</span>;
　　} @<span class="keyword">else</span> {
　　　　<span class="attribute">background-color</span>: <span class="number">#fff</span>;
　　}
</code></pre>
<h3 id="5-2-循环语句"><a href="#5-2-循环语句" class="headerlink" title="5.2 循环语句"></a>5.2 循环语句</h3><p>SASS支持<code>for</code>循环：</p>
<pre><code class="scss">　　@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 {
　　　　<span class="selector-class">.border-</span>#{<span class="variable">$i</span>} {
　　　　　　<span class="attribute">border</span>: #{<span class="variable">$i</span>}px solid blue;
　　　　}
　　}
</code></pre>
<p>也支持<code>while</code>循环：</p>
<pre><code class="scss">　　<span class="variable">$i</span>: <span class="number">6</span>;
　　@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 {
　　　　<span class="selector-class">.item-</span>#{<span class="variable">$i</span>} { <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; }
　　　　<span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;
　　}
</code></pre>
<p><code>each</code>命令，作用与<code>for</code>类似：</p>
<pre><code class="scss">　　@<span class="keyword">each</span> <span class="variable">$member</span> in a, b, c, d {
　　　　.#{<span class="variable">$member</span>} {
　　　　　　<span class="attribute">background-image</span>: url(<span class="string">"/image/#{$member}.jpg"</span>);
　　　　}
　　}
</code></pre>
<h3 id="5-3-自定义函数"><a href="#5-3-自定义函数" class="headerlink" title="5.3 自定义函数"></a>5.3 自定义函数</h3><p>SASS允许用户编写自己的函数。</p>
<pre><code class="scss">　　@function double(<span class="variable">$n</span>) {
　　　　@return <span class="variable">$n</span> * 2;
　　}
　　<span class="selector-id">#sidebar</span> {
　　　　<span class="attribute">width</span>: double(<span class="number">5px</span>);
　　}
</code></pre>
<h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><p><strong>感谢</strong>阮一峰老师的总结，<a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="external">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: SASS用法指南&lt;br&gt;date: 2017-03-18 23:17:32&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SASS&lt;/li&gt;
&lt;li&gt;SCSS&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/responsive/"/>
    <id>http://ecut.club/2017/04/19/responsive/</id>
    <published>2017-04-19T00:24:13.725Z</published>
    <updated>2017-03-03T13:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 响应式网页设计<br>date: 2017-03-02 22:55:31<br>tags:</p>
<ul>
<li>HTML5</li>
<li>CSS3</li>
<li>Responsive</li>
<li>响应式设计</li>
</ul>
<hr>
<h1 id="响应式网页设计"><a href="#响应式网页设计" class="headerlink" title="响应式网页设计"></a>响应式网页设计</h1><h2 id="什么是响应式网站"><a href="#什么是响应式网站" class="headerlink" title="什么是响应式网站"></a>什么是响应式网站</h2><p>响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。</p>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>优点：<br>面对不同分辨率设备灵活性强<br>能够快捷解决多设备显示适应问题</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>兼容各种设备工作量大，效率低下<br>代码累赘，会出现隐藏无用的元素，加载时间加长<br>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果<br>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>
<h2 id="响应式网页设计实战"><a href="#响应式网页设计实战" class="headerlink" title="响应式网页设计实战"></a>响应式网页设计实战</h2><p>用HTML5以及CSS3的媒体查询完成了一个响应式布局的demo，大家可以用不同的尺寸的设备，查看不同分辨率下的表现。也可以在控制台模拟各种设备，欢迎大家提出意见。😄</p>
<h2 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h2><p>在线预览地址1: 🔗<a href="http://microzz.cn/responsive/" target="_blank" rel="external">http://microzz.cn/responsive/</a><br>在线预览地址2: 🔗<a href="https://microzz.github.io/ResponsiveWeb/" target="_blank" rel="external">https://microzz.github.io/ResponsiveWeb/</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码地址：🔗<a href="https://github.com/microzz/ResponsiveWeb" target="_blank" rel="external">https://github.com/microzz/ResponsiveWeb</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 响应式网页设计&lt;br&gt;date: 2017-03-02 22:55:31&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML5&lt;/li&gt;
&lt;li&gt;CSS3&lt;/li&gt;
&lt;li&gt;Responsive&lt;/li&gt;
&lt;li&gt;响应式设计&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/regex/"/>
    <id>http://ecut.club/2017/04/19/regex/</id>
    <published>2017-04-19T00:24:13.725Z</published>
    <updated>2017-01-12T07:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 正则的扩展(RegExp)<br>date: 2016-11-20 15:57:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JavaScript
- ES6
- JS
- RegExp
- 正则表达式
</code></pre><hr>
<h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h2 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h2><p>在ES5中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<pre><code class="javascript"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);
<span class="comment">// 等价于</span>
<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;
</code></pre>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<pre><code class="javascript"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);
<span class="comment">// 等价于</span>
<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;
</code></pre>
<p>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">'i'</span>);
<span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span>
</code></pre>
<p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<pre><code class="javascript"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags
<span class="comment">// "i"</span>
</code></pre>
<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>
<h2 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h2><p>字符串对象共有4个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
<h2 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h2><p>ES6对正则表达式添加了<code>u</code>修饰符，含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<pre><code class="javascript">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)
<span class="comment">// false</span>
/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>)
<span class="comment">// true</span>
</code></pre>
<p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的UTF-16编码，代表一个字符。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>
<p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</p>
<p><strong>（1）点字符</strong></p>
<p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的Unicode字符，点字符不能识别，必须加上<code>u</code>修饰符。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;

<span class="regexp">/^.$/</span>.test(s) <span class="comment">// false</span>
/^.$/u.test(s) <span class="comment">// true</span>
</code></pre>
<p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>
<p><strong>（2）Unicode字符表示法</strong></p>
<p>ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别。</p>
<pre><code class="javascript">/\u{<span class="number">61</span>}/.test(<span class="string">'a'</span>) <span class="comment">// false</span>
/\u{<span class="number">61</span>}/u.test(<span class="string">'a'</span>) <span class="comment">// true</span>
/\u{<span class="number">20</span>BB7}/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span>
</code></pre>
<p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\u{61}</code>这种表示法，只会认为这匹配61个连续的<code>u</code>。</p>
<p><strong>（3）量词</strong></p>
<p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的Unicode字符。</p>
<pre><code class="javascript">/a{<span class="number">2</span>}/.test(<span class="string">'aa'</span>) <span class="comment">// true</span>
/a{<span class="number">2</span>}/u.test(<span class="string">'aa'</span>) <span class="comment">// true</span>
/𠮷{<span class="number">2</span>}/.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// false</span>
/𠮷{<span class="number">2</span>}/u.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// true</span>
</code></pre>
<p>另外，只有在使用<code>u</code>修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。</p>
<pre><code class="javascript">/^\u{<span class="number">3</span>}$/.test(<span class="string">'uuu'</span>) <span class="comment">// true</span>
</code></pre>
<p>上面代码中，由于正则表达式没有<code>u</code>修饰符，所以大括号被解读为量词。加上<code>u</code>修饰符，就会被解读为Unicode表达式。</p>
<p><strong>（4）预定义模式</strong></p>
<p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的Unicode字符。</p>
<pre><code class="javascript">/^\S$/.test(<span class="string">'𠮷'</span>) <span class="comment">// false</span>
/^\S$/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span>
</code></pre>
<p>上面代码的<code>\S</code>是预定义模式，匹配所有不是空格的字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的Unicode字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>{
  <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);
  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;
}

<span class="keyword">var</span> s = <span class="string">'𠮷𠮷'</span>;

s.length <span class="comment">// 4</span>
codePointLength(s) <span class="comment">// 2</span>
</code></pre>
<p><strong>（5）i修饰符</strong></p>
<p>有些Unicode字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>。</p>
<pre><code class="javascript">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span>
/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span>
</code></pre>
<p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的K字符。</p>
<h2 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h2><p>除了<code>u</code>修饰符，ES6还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>
<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;
<span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;
<span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;

r1.exec(s) <span class="comment">// ["aaa"]</span>
r2.exec(s) <span class="comment">// ["aaa"]</span>

r1.exec(s) <span class="comment">// ["aa"]</span>
r2.exec(s) <span class="comment">// null</span>
</code></pre>
<p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>
<pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;
<span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;

r.exec(s) <span class="comment">// ["aaa_"]</span>
r.exec(s) <span class="comment">// ["aa_"]</span>
</code></pre>
<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>使用<code>lastIndex</code>属性，可以更好地说明<code>y</code>修饰符。</p>
<pre><code class="javascript"><span class="keyword">const</span> REGEX = <span class="regexp">/a/g</span>;

<span class="comment">// 指定从2号位置（y）开始匹配</span>
REGEX.lastIndex = <span class="number">2</span>;

<span class="comment">// 匹配成功</span>
<span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaya'</span>);

<span class="comment">// 在3号位置匹配成功</span>
match.index <span class="comment">// 3</span>

<span class="comment">// 下一次匹配从4号位开始</span>
REGEX.lastIndex <span class="comment">// 4</span>

<span class="comment">// 4号位开始匹配失败</span>
REGEX.exec(<span class="string">'xaxa'</span>) <span class="comment">// null</span>
</code></pre>
<p>上面代码中，<code>lastIndex</code>属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p><code>y</code>修饰符同样遵守<code>lastIndex</code>属性，但是要求必须在<code>lastIndex</code>指定的位置发现匹配。</p>
<pre><code class="javascript"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span>;

<span class="comment">// 指定从2号位置开始匹配</span>
REGEX.lastIndex = <span class="number">2</span>;

<span class="comment">// 不是粘连，匹配失败</span>
REGEX.exec(<span class="string">'xaya'</span>) <span class="comment">// null</span>

<span class="comment">// 指定从3号位置开始匹配</span>
REGEX.lastIndex = <span class="number">3</span>;

<span class="comment">// 3号位置是粘连，匹配成功</span>
<span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaxa'</span>);
match.index <span class="comment">// 3</span>
REGEX.lastIndex <span class="comment">// 4</span>
</code></pre>
<p>进一步说，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<pre><code class="javascript">/b/y.exec(<span class="string">'aba'</span>)
<span class="comment">// null</span>
</code></pre>
<p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p>
<p>在<code>split</code>方法中使用<code>y</code>修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。</p>
<pre><code class="javascript"><span class="comment">// 没有找到匹配</span>
<span class="string">'x##'</span>.split(<span class="regexp">/#/y</span>)
<span class="comment">// [ 'x##' ]</span>

<span class="comment">// 找到两个匹配</span>
<span class="string">'##x'</span>.split(<span class="regexp">/#/y</span>)
<span class="comment">// [ '', '', 'x' ]</span>
</code></pre>
<p>后续的分隔符只有紧跟前面的分隔符，才会被识别。</p>
<pre><code class="javascript"><span class="string">'#x#'</span>.split(<span class="regexp">/#/y</span>)
<span class="comment">// [ '', 'x#' ]</span>

<span class="string">'##'</span>.split(<span class="regexp">/#/y</span>)
<span class="comment">// [ '', '', '' ]</span>
</code></pre>
<p>下面是字符串对象的<code>replace</code>方法的例子。</p>
<pre><code class="javascript"><span class="keyword">const</span> REGEX = <span class="regexp">/a/gy</span>;
<span class="string">'aaxa'</span>.replace(REGEX, <span class="string">'-'</span>) <span class="comment">// '--xa'</span>
</code></pre>
<p>上面代码中，最后一个<code>a</code>因为不是出现下一次匹配的头部，所以不会被替换。</p>
<p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p>
<pre><code class="javascript"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/y</span>) <span class="comment">// ["a1"]</span>
<span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/gy</span>) <span class="comment">// ["a1", "a2", "a3"]</span>
</code></pre>
<p><code>y</code>修饰符的一个应用，是从字符串提取token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<pre><code class="javascript"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;
<span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;

tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)
<span class="comment">// [ '3', '+', '4' ]</span>
tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)
<span class="comment">// [ '3', '+', '4' ]</span>

<span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>{
  <span class="keyword">let</span> result = [];
  <span class="keyword">let</span> match;
  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) {
    result.push(match[<span class="number">1</span>]);
  }
  <span class="keyword">return</span> result;
}
</code></pre>
<p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>
<pre><code class="javascript">tokenize(TOKEN_Y, <span class="string">'3x + 4'</span>)
<span class="comment">// [ '3' ]</span>
tokenize(TOKEN_G, <span class="string">'3x + 4'</span>)
<span class="comment">// [ '3', '+', '4' ]</span>
</code></pre>
<p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误。</p>
<h2 id="sticky属性"><a href="#sticky属性" class="headerlink" title="sticky属性"></a>sticky属性</h2><p>与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<pre><code class="javascript"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;
r.sticky <span class="comment">// true</span>
</code></pre>
<h2 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h2><p>ES6为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>
<pre><code class="javascript"><span class="comment">// ES5的source属性</span>
<span class="comment">// 返回正则表达式的正文</span>
/abc/ig.source
<span class="comment">// "abc"</span>

<span class="comment">// ES6的flags属性</span>
<span class="comment">// 返回正则表达式的修饰符</span>
/abc/ig.flags
<span class="comment">// 'gi'</span>
</code></pre>
<h2 id="RegExp-escape"><a href="#RegExp-escape" class="headerlink" title="RegExp.escape()"></a>RegExp.escape()</h2><p>字符串必须转义，才能作为正则模式。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">escapeRegExp</span>(<span class="params">str</span>) </span>{
  <span class="keyword">return</span> str.replace(<span class="regexp">/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g</span>, <span class="string">'\\$&amp;'</span>);
}

<span class="keyword">let</span> str = <span class="string">'/path/to/resource.html?search=query'</span>;
escapeRegExp(str)
<span class="comment">// "\/path\/to\/resource\.html\?search=query"</span>
</code></pre>
<p>上面代码中，<code>str</code>是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。</p>
<p>已经有<a href="https://esdiscuss.org/topic/regexp-escape" target="_blank" rel="external">提议</a>将这个需求标准化，作为RegExp对象的静态方法<a href="https://github.com/benjamingr/RexExp.escape" target="_blank" rel="external">RegExp.escape()</a>，放入ES7。2015年7月31日，TC39认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入ES7，但这不失为一个真实的需求。</p>
<pre><code class="javascript"><span class="built_in">RegExp</span>.escape(<span class="string">'The Quick Brown Fox'</span>);
<span class="comment">// "The Quick Brown Fox"</span>

<span class="built_in">RegExp</span>.escape(<span class="string">'Buy it. use it. break it. fix it.'</span>);
<span class="comment">// "Buy it\. use it\. break it\. fix it\."</span>

<span class="built_in">RegExp</span>.escape(<span class="string">'(*.*)'</span>);
<span class="comment">// "\(\*\.\*\)"</span>
</code></pre>
<p>字符串转义以后，可以使用RegExp构造函数生成正则模式。</p>
<pre><code class="javascript"><span class="keyword">var</span> str = <span class="string">'hello. how are you?'</span>;
<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="built_in">RegExp</span>.escape(str), <span class="string">'g'</span>);
assert.equal(<span class="built_in">String</span>(regex), <span class="string">'/hello\. how are you\?/g'</span>);
</code></pre>
<p>目前，该方法可以用上文的<code>escapeRegExp</code>函数或者垫片模块<a href="https://github.com/ljharb/regexp.escape" target="_blank" rel="external">regexp.escape</a>实现。</p>
<pre><code class="javascript"><span class="keyword">var</span> <span class="built_in">escape</span> = <span class="built_in">require</span>(<span class="string">'regexp.escape'</span>);
<span class="built_in">escape</span>(<span class="string">'hi. how are you?'</span>);
<span class="comment">// "hi\\. how are you\\?"</span>
</code></pre>
<h2 id="s-修饰符：dotAll-模式"><a href="#s-修饰符：dotAll-模式" class="headerlink" title="s 修饰符：dotAll 模式"></a>s 修饰符：dotAll 模式</h2><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。</p>
<p>以下四个字符属于”行终止符“。</p>
<ul>
<li>U+000A 换行符（<code>\n</code>）</li>
<li>U+000D 回车符（<code>\r</code>）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<pre><code class="javascript">/foo.bar/.test(<span class="string">'foo\nbar'</span>)
<span class="comment">// false</span>
</code></pre>
<p>上面代码中，因为<code>.</code>不匹配<code>\n</code>，所以正则表达式返回<code>false</code>。</p>
<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>
<pre><code class="javascript">/foo[^]bar/.test(<span class="string">'foo\nbar'</span>)
<span class="comment">// true</span>
</code></pre>
<p>这种解决方案毕竟不太符合直觉，所以现在有一个<a href="https://github.com/mathiasbynens/es-regexp-dotall-flag" target="_blank" rel="external">提案</a>，引入<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<pre><code class="javascript">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span>
</code></pre>
<p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>
<pre><code class="javascript"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;
<span class="comment">// 另一种写法</span>
<span class="comment">// const re = new RegExp('foo.bar', 's');</span>

re.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span>
re.dotAll <span class="comment">// true</span>
re.flags <span class="comment">// 's'</span>
</code></pre>
<p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾。</p>
<h2 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h2><p>JavaScript语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。</p>
<p>目前，有一个<a href="https://github.com/goyakin/es-regexp-lookbehind" target="_blank" rel="external">提案</a>，在ES7加入后行断言。V8引擎4.9版已经支持，Chrome浏览器49版打开”experimental JavaScript features“开关（地址栏键入<code>about:flags</code>），就可以使用这项功能。</p>
<p>”先行断言“指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。”先行否定断言“指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<pre><code class="javascript">/\d+(?=%)/.exec(<span class="string">'100% of US presidents have been male'</span>)  <span class="comment">// ["100"]</span>
/\d+(?!%)/.exec(<span class="string">'that’s all 44 of them'</span>)                 <span class="comment">// ["44"]</span>
</code></pre>
<p>上面两个字符串，如果互换正则表达式，就会匹配失败。另外，还可以看到，”先行断言“括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p>
<p>“后行断言”正好与”先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。”后行否定断言“则与”先行否定断言“相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<pre><code class="javascript">/(?<span class="xml"><span class="tag">&lt;<span class="name">=\$)\d+</span>/<span class="attr">.exec</span>('<span class="attr">Benjamin</span> <span class="attr">Franklin</span> <span class="attr">is</span> <span class="attr">on</span> <span class="attr">the</span> $<span class="attr">100</span> <span class="attr">bill</span>')  // ["<span class="attr">100</span>"]
/(?&lt;!\$)\<span class="attr">d</span>+/<span class="attr">.exec</span>('<span class="attr">it</span>’<span class="attr">s</span> <span class="attr">is</span> <span class="attr">worth</span> <span class="attr">about</span> €<span class="attr">90</span>')                // ["<span class="attr">90</span>"]</span></span>
</code></pre>
<p>上面的例子中，”后行断言”的括号之中的部分（<code>(?&lt;=\$)</code>），也是不计入返回结果。</p>
<p>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的<code>x</code>，然后再回到左边，匹配<code>y</code>的部分。这种”先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>
<p>首先，”后行断言“的组匹配，与正常情况下结果是不一样的。</p>
<pre><code class="javascript">/(?<span class="xml"><span class="tag">&lt;<span class="name">=(\d+)(\d+))$</span>/<span class="attr">.exec</span>('<span class="attr">1053</span>') // ["", "<span class="attr">1</span>", "<span class="attr">053</span>"]
/^(\<span class="attr">d</span>+)(\<span class="attr">d</span>+)$/<span class="attr">.exec</span>('<span class="attr">1053</span>') // ["<span class="attr">1053</span>", "<span class="attr">105</span>", "<span class="attr">3</span>"]</span></span>
</code></pre>
<p>上面代码中，需要捕捉两个组匹配。没有”后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而”后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p>
<p>其次，”后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>
<pre><code class="javascript">/(?<span class="xml"><span class="tag">&lt;<span class="name">=(o)d\1)r</span>/<span class="attr">.exec</span>('<span class="attr">hodor</span>')  // <span class="attr">null</span>
/(?&lt;=<span class="string">\1d(o))r/.exec(</span>'<span class="attr">hodor</span>')  // ["<span class="attr">r</span>", "<span class="attr">o</span>"]</span></span>
</code></pre>
<p>上面代码中，如果后行断言的反斜杠引用（<code>\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。</p>
<h2 id="Unicode属性类"><a href="#Unicode属性类" class="headerlink" title="Unicode属性类"></a>Unicode属性类</h2><p>目前，有一个<a href="https://github.com/mathiasbynens/es-regexp-unicode-property-escapes" target="_blank" rel="external">提案</a>，引入了一种新的类的写法<code>\p{...}</code>和<code>\P{...}</code>，允许正则表达式匹配符合Unicode某种属性的所有字符。</p>
<pre><code class="javascript"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p{Script=Greek}/u</span>;
regexGreekSymbol.test(<span class="string">'π'</span>) <span class="comment">// u</span>
</code></pre>
<p>上面代码中，<code>\p{Script=Greek}</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p>
<p>Unicode属性类要指定属性名和属性值。</p>
<pre><code class="javascript">\p{UnicodePropertyName=UnicodePropertyValue}
</code></pre>
<p>对于某些属性，可以只写属性名。</p>
<pre><code class="javascript">\p{UnicodePropertyName}
</code></pre>
<p><code>\P{…}</code>是<code>\p{…}</code>的反向匹配，即匹配不满足条件的字符。</p>
<p>注意，这两种类只对Unicode有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加<code>u</code>修饰符，正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript预留了这两个类。</p>
<p>由于Unicode的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<pre><code class="javascript"><span class="keyword">const</span> regex = <span class="regexp">/^\p{Decimal_Number}+$/u</span>;
regex.test(<span class="string">'𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'</span>) <span class="comment">// true</span>
</code></pre>
<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>
<p><code>\p{Number}</code>甚至能匹配罗马数字。</p>
<pre><code class="javascript"><span class="comment">// 匹配所有数字</span>
<span class="keyword">const</span> regex = <span class="regexp">/^\p{Number}+$/u</span>;
regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span>
regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span>
regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span>
</code></pre>
<p>下面是其他一些例子。</p>
<pre><code class="javascript"><span class="comment">// 匹配各种文字的所有字母，等同于Unicode版的\w</span>
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

<span class="comment">// 匹配各种文字的所有非字母的字符，等同于Unicode版的\W</span>
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

<span class="comment">// 匹配所有的箭头字符</span>
<span class="keyword">const</span> regexArrows = <span class="regexp">/^\p{Block=Arrows}+$/u</span>;
regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) <span class="comment">// true</span>
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 正则的扩展(RegExp)&lt;br&gt;date: 2016-11-20 15:57:19&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ECMAScript6
- JavaScript
- JavaScript
- ES6
- JS
- RegEx
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/reflect/"/>
    <id>http://ecut.club/2017/04/19/reflect/</id>
    <published>2017-04-19T00:24:13.710Z</published>
    <updated>2017-01-12T08:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Reflect<br>date: 2017-01-11 08:25:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JS
- ES6
- Reflect
</code></pre><hr>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>
<p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>
<pre><code class="javascript"><span class="comment">// 老写法</span>
<span class="keyword">try</span> {
  <span class="built_in">Object</span>.defineProperty(target, property, attributes);
  <span class="comment">// success</span>
} <span class="keyword">catch</span> (e) {
  <span class="comment">// failure</span>
}

<span class="comment">// 新写法</span>
<span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) {
  <span class="comment">// success</span>
} <span class="keyword">else</span> {
  <span class="comment">// failure</span>
}
</code></pre>
<p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<pre><code class="javascript"><span class="comment">// 老写法</span>
<span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span>
</code></pre>
<p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<pre><code class="javascript"><span class="built_in">Proxy</span>(target, {
  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>{
    <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target,name, value, receiver);
    <span class="keyword">if</span> (success) {
      log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);
    }
    <span class="keyword">return</span> success;
  }
});
</code></pre>
<p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {
  get(target, name) {
    <span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);
  },
  deleteProperty(target, name) {
    <span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);
  },
  has(target, name) {
    <span class="built_in">console</span>.log(<span class="string">'has'</span> + name);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);
  }
});
</code></pre>
<p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p>
<pre><code class="javascript"><span class="comment">// 老写法</span>
<span class="built_in">Function</span>.prototype.apply.call(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span>
</code></pre>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Reflect</code>对象一共有13个静态方法。</p>
<ul>
<li>Reflect.apply(target,thisArg,args)</li>
<li>Reflect.construct(target,args)</li>
<li>Reflect.get(target,name,receiver)</li>
<li>Reflect.set(target,name,value,receiver)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.deleteProperty(target,name)</li>
<li>Reflect.has(target,name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p>
<h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  <span class="attr">bar</span>: <span class="number">2</span>,
  get baz() {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;
  },
}

<span class="built_in">Reflect</span>.get(myObject, <span class="string">'foo'</span>) <span class="comment">// 1</span>
<span class="built_in">Reflect</span>.get(myObject, <span class="string">'bar'</span>) <span class="comment">// 2</span>
<span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>) <span class="comment">// 3</span>
</code></pre>
<p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  <span class="attr">bar</span>: <span class="number">2</span>,
  get baz() {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;
  },
};

<span class="keyword">var</span> myReceiverObject = {
  <span class="attr">foo</span>: <span class="number">4</span>,
  <span class="attr">bar</span>: <span class="number">4</span>,
};

<span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>, myReceiverObject) <span class="comment">// 8</span>
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>
<pre><code class="javascript"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">'foo'</span>) <span class="comment">// 报错</span>
<span class="built_in">Reflect</span>.get(<span class="literal">false</span>, <span class="string">'foo'</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  set bar(value) {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;
  },
}

myObject.foo <span class="comment">// 1</span>

<span class="built_in">Reflect</span>.set(myObject, <span class="string">'foo'</span>, <span class="number">2</span>);
myObject.foo <span class="comment">// 2</span>

<span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">3</span>)
myObject.foo <span class="comment">// 3</span>
</code></pre>
<p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">4</span>,
  set bar(value) {
    <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;
  },
};

<span class="keyword">var</span> myReceiverObject = {
  <span class="attr">foo</span>: <span class="number">0</span>,
};

<span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">1</span>, myReceiverObject);
myObject.foo <span class="comment">// 4</span>
myReceiverObject.foo <span class="comment">// 1</span>
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>
<pre><code class="javascript"><span class="built_in">Reflect</span>.set(<span class="number">1</span>, <span class="string">'foo'</span>, {}) <span class="comment">// 报错</span>
<span class="built_in">Reflect</span>.set(<span class="literal">false</span>, <span class="string">'foo'</span>, {}) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
};

<span class="comment">// 旧写法</span>
<span class="string">'foo'</span> <span class="keyword">in</span> myObject <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.has(myObject, <span class="string">'foo'</span>) <span class="comment">// true</span>
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.has</code>和<code>in</code>运算符都会报错。</p>
<h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObj = { <span class="attr">foo</span>: <span class="string">'bar'</span> };

<span class="comment">// 旧写法</span>
<span class="keyword">delete</span> myObj.foo;

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.deleteProperty(myObj, <span class="string">'foo'</span>);
</code></pre>
<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p>
<h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">name</span>) </span>{
  <span class="keyword">this</span>.name = name;
}

<span class="comment">// new 的写法</span>
<span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(<span class="string">'张三'</span>);

<span class="comment">// Reflect.construct 的写法</span>
<span class="keyword">const</span> instance = <span class="built_in">Reflect</span>.construct(Greeting, <span class="string">'张三'</span>);
</code></pre>
<h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.getPrototypeOf(myObj) === FancyThing.prototype;

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.getPrototypeOf(myObj) === FancyThing.prototype;
</code></pre>
<p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果第一个参数不是对象（包括<code>null</code>和<code>undefined</code>），<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// undefined</span>
<span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置对象的<code>__proto__</code>属性，对应<code>Object.setPrototypeOf(obj, newProto)</code>。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.setPrototypeOf(myObj, OtherThing.prototype);

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.setPrototypeOf(myObj, OtherThing.prototype);
</code></pre>
<p>如果第一个参数不是对象，<code>Reflect.setPrototypeOf</code>和<code>Object.setPrototypeOf</code>都会报错。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span>
<span class="built_in">Reflect</span>.setPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p>
<p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p>
<pre><code class="javascript"><span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];

<span class="comment">// 旧写法</span>
<span class="keyword">const</span> youngest = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, ages);
<span class="keyword">const</span> oldest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, ages);
<span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(youngest);

<span class="comment">// 新写法</span>
<span class="keyword">const</span> youngest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>, ages);
<span class="keyword">const</span> oldest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.max, <span class="built_in">Math</span>, ages);
<span class="keyword">const</span> type = <span class="built_in">Reflect</span>.apply(<span class="built_in">Object</span>.prototype.toString, youngest);
</code></pre>
<h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>{
  <span class="comment">/*…*/</span>
}

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.defineProperty(MyDate, <span class="string">'now'</span>, {
  <span class="attr">value</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>.now()
});

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.defineProperty(MyDate, <span class="string">'now'</span>, {
  <span class="attr">value</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>.now()
});
</code></pre>
<p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p>
<h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {};
<span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'hidden'</span>, {
  <span class="attr">value</span>: <span class="literal">true</span>,
  <span class="attr">enumerable</span>: <span class="literal">false</span>,
});

<span class="comment">// 旧写法</span>
<span class="keyword">var</span> theDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);

<span class="comment">// 新写法</span>
<span class="keyword">var</span> theDescriptor = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);
</code></pre>
<p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p>
<h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>
<pre><code class="javascript"><span class="keyword">const</span> myObject = {};

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.isExtensible(myObject) <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.isExtensible(myObject) <span class="comment">// true</span>
</code></pre>
<p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.isExtensible(<span class="number">1</span>) <span class="comment">// false</span>
<span class="built_in">Reflect</span>.isExtensible(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {};

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.isExtensible(myObject) <span class="comment">// true</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.preventExtensions(myObject) <span class="comment">// true</span>
</code></pre>
<p>如果参数不是对象，<code>Object.isExtensible</code>在 ES5 环境报错，在 ES6 环境返回这个参数，而<code>Reflect.preventExtensions</code>会报错。</p>
<pre><code class="javascript"><span class="comment">// ES5</span>
<span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 报错</span>

<span class="comment">// ES6</span>
<span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 1</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 报错</span>
</code></pre>
<h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p>
<pre><code class="javascript"><span class="keyword">var</span> myObject = {
  <span class="attr">foo</span>: <span class="number">1</span>,
  <span class="attr">bar</span>: <span class="number">2</span>,
  [<span class="built_in">Symbol</span>.for(<span class="string">'baz'</span>)]: <span class="number">3</span>,
  [<span class="built_in">Symbol</span>.for(<span class="string">'bing'</span>)]: <span class="number">4</span>,
};

<span class="comment">// 旧写法</span>
<span class="built_in">Object</span>.getOwnPropertyNames(myObject)
<span class="comment">// ['foo', 'bar']</span>

<span class="built_in">Object</span>.getOwnPropertySymbols(myObject)
<span class="comment">//[Symbol.for('baz'), Symbol.for('bing')]</span>

<span class="comment">// 新写法</span>
<span class="built_in">Reflect</span>.ownKeys(myObject)
<span class="comment">// ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]</span>
</code></pre>
<h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<pre><code class="javascript"><span class="keyword">const</span> person = observable({
  <span class="attr">name</span>: <span class="string">'张三'</span>,
  <span class="attr">age</span>: <span class="number">20</span>
});

<span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${person.name}</span>, <span class="subst">${person.age}</span>`</span>)
}

observe(print);
person.name = <span class="string">'李四'</span>;
<span class="comment">// 输出</span>
<span class="comment">// 李四, 20</span>
</code></pre>
<p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p>
<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<pre><code class="javascript"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();

<span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);
<span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {set});

<span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>{
  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);
  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());
  <span class="keyword">return</span> result;
}
</code></pre>
<p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Reflect&lt;br&gt;date: 2017-01-11 08:25:19&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ECMAScript6
- JavaScript
- JS
- ES6
- Reflect
&lt;/code&gt;&lt;/pre&gt;&lt;hr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/react-news/"/>
    <id>http://ecut.club/2017/04/19/react-news/</id>
    <published>2017-04-19T00:24:13.710Z</published>
    <updated>2017-04-11T14:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: ReactJS新闻App<br>date: 2017-03-29 19:58:19<br>tags:</p>
<ul>
<li>JavaScript</li>
<li>JS</li>
<li>ReactJS</li>
<li>ES6</li>
<li>ECMAScript6</li>
</ul>
<hr>
<h1 id="ReactNewsApp"><a href="#ReactNewsApp" class="headerlink" title="ReactNewsApp"></a>ReactNewsApp</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个由React.js编写的新闻WebApp。<br>A news WebApp by React.js.<br>本应用仅供学习，请不要用于商业用途，供学习交流😁<br>因为技术有限，所以可能有好多不足，欢迎提建议哦😄<br> 👉 <a href="https://github.com/microzz/news-app-by-react.js" target="_blank" rel="external">项目地址</a></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="React-js组件化开发"><a href="#React-js组件化开发" class="headerlink" title="React.js组件化开发"></a>React.js组件化开发</h3><p>项目采用组件化的思想，把大的功能模块划分成一个个小的模块，便于团队合作和维护。</p>
<h3 id="react-router路由管理"><a href="#react-router路由管理" class="headerlink" title="react-router路由管理"></a>react-router路由管理</h3><p>路由库React-Router，它是官方维护的，事实上也是唯一可选的路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到，特别是SPA(单页应用)</p>
<h3 id="antd使页面更加美观"><a href="#antd使页面更加美观" class="headerlink" title="antd使页面更加美观"></a>antd使页面更加美观</h3><p>Ant Design 是蚂蚁金服开发和正在使用的一套企业级的前端设计语言和基于 React 的前端框架实现。</p>
<ul>
<li>特性</li>
</ul>
<p>企业级金融产品的交互语言和视觉体系。</p>
<p>丰富实用的 React UI 组件。</p>
<p>基于 React 的组件化开发模式。</p>
<p>背靠 npm 生态圈。</p>
<p>基于 webpack 的调试构建方案，支持 ES6。</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack作为构建工具</p>
<h4 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h4><p>全面采用ES6语法</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>本项目以慕课网视频为原型开发，大家可以发挥想象改进功能😄 </p>
<p>下载下来之后，先安装依赖 <code>npm install</code> 或者 <code>cnpm install</code>，然后： </p>
<p><code>npm run dev</code> or <code>npm run build</code></p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>PC端<br><img src="https://icdn.microzz.com/20170329_react_news/pc-index.png" alt="react-news by microzz.com"></p>
<p>手机端</p>
<p><img src="https://icdn.microzz.com/20170329_react_news/phone.png" alt="react-news by microzz.com"></p>
<p>👉 <a href="https://microzz.com/" target="_blank" rel="external">个人技术网站</a><br>👉<a href="https://github.com/microzz" target="_blank" rel="external">GitHub</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: ReactJS新闻App&lt;br&gt;date: 2017-03-29 19:58:19&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;ReactJS&lt;/li&gt;
&lt;li&gt;ES6&lt;/li&gt;
&lt;li
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/react-mind-map/"/>
    <id>http://ecut.club/2017/04/19/react-mind-map/</id>
    <published>2017-04-19T00:24:13.694Z</published>
    <updated>2017-03-31T08:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: React.JS学习思维导图<br>date: 2017-02-21 21:41:34<br>tags:</p>
<ul>
<li>ReactJS</li>
<li>JS</li>
<li>JavaScript</li>
<li>ES6</li>
<li>ECMAScript6</li>
</ul>
<hr>
<h1 id="React-JS学习思维导图"><a href="#React-JS学习思维导图" class="headerlink" title="React.JS学习思维导图"></a>React.JS学习思维导图</h1><h2 id="ReactJS简介"><a href="#ReactJS简介" class="headerlink" title="ReactJS简介"></a>ReactJS简介</h2><p>React 是一个用于构建用户界面的 JAVASCRIPT 库。<br>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。<br>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。<br>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><h3 id="在线预览地址"><a href="#在线预览地址" class="headerlink" title="在线预览地址"></a>在线预览地址</h3><p><img src="https://icdn.microzz.com/20170221_react_mind_map/mind-map-for-react.png" alt="mind map for react - microzz.com"></p>
<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p><a href="https://github.com/microzz/mind-map-for-react" target="_blank" rel="external">React.JS学习思维导图</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: React.JS学习思维导图&lt;br&gt;date: 2017-02-21 21:41:34&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReactJS&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;ES6&lt;/li&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ecut.club/2017/04/19/proxy/"/>
    <id>http://ecut.club/2017/04/19/proxy/</id>
    <published>2017-04-19T00:24:13.694Z</published>
    <updated>2017-01-12T08:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: Proxy<br>date: 2017-01-09 10:40:19<br>tags:</p>
<pre><code>- ECMAScript6
- JavaScript
- JS
- ES6
- Proxy
</code></pre><hr>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">${key}</span>!`</span>);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);
  },
  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">${key}</span>!`</span>);
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);
  }
});
</code></pre>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<pre><code class="javascript">obj.count = <span class="number">1</span>
<span class="comment">//  setting count!</span>
++obj.count
<span class="comment">//  getting count!</span>
<span class="comment">//  setting count!</span>
<span class="comment">//  2</span>
</code></pre>
<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code class="javascript"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
</code></pre>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>{
    <span class="keyword">return</span> <span class="number">35</span>;
  }
});

proxy.time <span class="comment">// 35</span>
proxy.name <span class="comment">// 35</span>
proxy.title <span class="comment">// 35</span>
</code></pre>
<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<pre><code class="javascript"><span class="keyword">var</span> target = {};
<span class="keyword">var</span> handler = {};
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
proxy.a = <span class="string">'b'</span>;
target.a <span class="comment">// "b"</span>
</code></pre>
<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>handler</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<pre><code class="javascript"><span class="keyword">var</span> object = { <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler) };
</code></pre>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code class="javascript"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>{
    <span class="keyword">return</span> <span class="number">35</span>;
  }
});

<span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);
obj.time <span class="comment">// 35</span>
</code></pre>
<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>{
    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) {
      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;
    }
    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;
  },

  <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>{
    <span class="keyword">return</span> args[<span class="number">0</span>];
  },

  <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>{
    <span class="keyword">return</span> {<span class="attr">value</span>: args[<span class="number">1</span>]};
  }
};

<span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>{
  <span class="keyword">return</span> x + y;
}, handler);

fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span>
<span class="keyword">new</span> fproxy(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// {value: 2}</span>
fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span>
fproxy.foo <span class="comment">// "Hello, foo"</span>
</code></pre>
<p>下面是 Proxy 支持的拦截操作一览。</p>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p><strong>（1）get(target, propKey, receiver)</strong></p>
<p>拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</p>
<p>最后一个参数<code>receiver</code>是一个对象，可选，参见下面<code>Reflect.get</code>的部分。</p>
<p><strong>（2）set(target, propKey, value, receiver)</strong></p>
<p>拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p>
<p><strong>（3）has(target, propKey)</strong></p>
<p>拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p>
<p><strong>（4）deleteProperty(target, propKey)</strong></p>
<p>拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p>
<p><strong>（5）ownKeys(target)</strong></p>
<p>拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</p>
<p><strong>（6）getOwnPropertyDescriptor(target, propKey)</strong></p>
<p>拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p>
<p><strong>（7）defineProperty(target, propKey, propDesc)</strong></p>
<p>拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p>
<p><strong>（8）preventExtensions(target)</strong></p>
<p>拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p>
<p><strong>（9）getPrototypeOf(target)</strong></p>
<p>拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p>
<p><strong>（10）isExtensible(target)</strong></p>
<p>拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p>
<p><strong>（11）setPrototypeOf(target, proto)</strong></p>
<p>拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</p>
<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<p><strong>（12）apply(target, object, args)</strong></p>
<p>拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p>
<p><strong>（13）construct(target, args)</strong></p>
<p>拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</p>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> person = {
  <span class="attr">name</span>: <span class="string">"张三"</span>
};

<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, {
  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>{
    <span class="keyword">if</span> (property <span class="keyword">in</span> target) {
      <span class="keyword">return</span> target[property];
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);
    }
  }
});

proxy.name <span class="comment">// "张三"</span>
proxy.age <span class="comment">// 抛出一个错误</span>
</code></pre>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>
<p><code>get</code>方法可以继承。</p>
<pre><code class="javascript"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  get(target, propertyKey, receiver) {
    <span class="built_in">console</span>.log(<span class="string">'GET '</span>+propertyKey);
    <span class="keyword">return</span> target[propertyKey];
  }
});

<span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proto);
obj.xxx <span class="comment">// "GET xxx"</span>
</code></pre>
<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>{
  <span class="keyword">let</span> handler = {
    get(target, propKey, receiver) {
      <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);
      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {
        propKey = <span class="built_in">String</span>(target.length + index);
      }
      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);
    }
  };

  <span class="keyword">let</span> target = [];
  target.push(...elements);
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
}

<span class="keyword">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);
arr[<span class="number">-1</span>] <span class="comment">// c</span>
</code></pre>
<p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数最后一个成员。</p>
<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<pre><code class="javascript"><span class="keyword">var</span> pipe = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>{
    <span class="keyword">var</span> funcStack = [];
    <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>({} , {
      <span class="attr">get</span> : <span class="function"><span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) </span>{
        <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) {
          <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>{
            <span class="keyword">return</span> fn(val);
          },value);
        }
        funcStack.push(<span class="built_in">window</span>[fnName]);
        <span class="keyword">return</span> oproxy;
      }
    });

    <span class="keyword">return</span> oproxy;
  }
}());

<span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;
<span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;
<span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;

pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span>
</code></pre>
<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种DOM节点的通用函数<code>dom</code>。</p>
<pre><code class="javascript"><span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  get(target, property) {
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">attrs = {}, ...children</span>) </span>{
      <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(property);
      <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(attrs)) {
        el.setAttribute(prop, attrs[prop]);
      }
      <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) {
        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'string'</span>) {
          child = <span class="built_in">document</span>.createTextNode(child);
        }
        el.appendChild(child);
      }
      <span class="keyword">return</span> el;
    }
  }
});

<span class="keyword">const</span> el = dom.div({},
  <span class="string">'Hello, my name is '</span>,
  dom.a({<span class="attr">href</span>: <span class="string">'//example.com'</span>}, <span class="string">'Mark'</span>),
  <span class="string">'. I like:'</span>,
  dom.ul({},
    dom.li({}, <span class="string">'The web'</span>),
    dom.li({}, <span class="string">'Food'</span>),
    dom.li({}, <span class="string">'…actually that\'s it'</span>)
  )
);

<span class="built_in">document</span>.body.appendChild(el);
</code></pre>
<p>如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错。</p>
<pre><code class="javascript"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties({}, {
  <span class="attr">foo</span>: {
    <span class="attr">value</span>: <span class="number">123</span>,
    <span class="attr">writable</span>: <span class="literal">false</span>,
    <span class="attr">configurable</span>: <span class="literal">false</span>
  },
});

<span class="keyword">const</span> handler = {
  get(target, propKey) {
    <span class="keyword">return</span> <span class="string">'abc'</span>;
  }
};

<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

proxy.foo
<span class="comment">// TypeError: Invariant check failed</span>
</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作。</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于200的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>
<pre><code class="javascript"><span class="keyword">let</span> validator = {
  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>) </span>{
    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) {
      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);
      }
      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);
      }
    }

    <span class="comment">// 对于age以外的属性，直接保存</span>
    obj[prop] = value;
  }
};

<span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, validator);

person.age = <span class="number">100</span>;

person.age <span class="comment">// 100</span>
person.age = <span class="string">'young'</span> <span class="comment">// 报错</span>
person.age = <span class="number">300</span> <span class="comment">// 报错</span>
</code></pre>
<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  get (target, key) {
    invariant(key, <span class="string">'get'</span>);
    <span class="keyword">return</span> target[key];
  },
  set (target, key, value) {
    invariant(key, <span class="string">'set'</span>);
    target[key] = value;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
<span class="function"><span class="keyword">function</span> <span class="title">invariant</span> (<span class="params">key, action</span>) </span>{
  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">${action}</span> private "<span class="subst">${key}</span>" property`</span>);
  }
}
<span class="keyword">var</span> target = {};
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
proxy._prop
<span class="comment">// Error: Invalid attempt to get private "_prop" property</span>
proxy._prop = <span class="string">'c'</span>
<span class="comment">// Error: Invalid attempt to set private "_prop" property</span>
</code></pre>
<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p>注意，如果目标对象自身的某个属性，不可写也不可配置，那么<code>set</code>不得改变这个属性的值，只能返回同样的值，否则报错。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  apply (target, ctx, args) {
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);
  }
};
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="string">'I am the target'</span>; };
<span class="keyword">var</span> handler = {
  <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;
  }
};

<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

p()
<span class="comment">// "I am the proxy"</span>
</code></pre>
<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>
<p>下面是另外一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> twice = {
  apply (target, ctx, args) {
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments) * <span class="number">2</span>;
  }
};
<span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">left, right</span>) </span>{
  <span class="keyword">return</span> left + right;
};
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, twice);
proxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span>
proxy.call(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span>
proxy.apply(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span>
</code></pre>
<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>
<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>
<pre><code class="javascript"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span>
</code></pre>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p>下面的例子使用<code>has</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  has (target, key) {
    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> key <span class="keyword">in</span> target;
  }
};
<span class="keyword">var</span> target = { <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span> };
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
<span class="string">'_prop'</span> <span class="keyword">in</span> proxy <span class="comment">// false</span>
</code></pre>
<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has</code>拦截会报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = { <span class="attr">a</span>: <span class="number">10</span> };
<span class="built_in">Object</span>.preventExtensions(obj);

<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {
  <span class="attr">has</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>{
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
});

<span class="string">'a'</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span>
</code></pre>
<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>
<p>值得注意的是，<code>has</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has</code>拦截对<code>for...in</code>循环不生效。</p>
<pre><code class="javascript"><span class="keyword">let</span> stu1 = {<span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">score</span>: <span class="number">59</span>};
<span class="keyword">let</span> stu2 = {<span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">score</span>: <span class="number">99</span>};

<span class="keyword">let</span> handler = {
  has(target, prop) {
    <span class="keyword">if</span> (prop === <span class="string">'score'</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) {
      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${target.name}</span> 不及格`</span>);
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> prop <span class="keyword">in</span> target;
  }
}

<span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu1, handler);
<span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu2, handler);

<span class="string">'score'</span> <span class="keyword">in</span> oproxy1
<span class="comment">// 张三 不及格</span>
<span class="comment">// false</span>

<span class="string">'score'</span> <span class="keyword">in</span> oproxy2
<span class="comment">// true</span>

<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) {
  <span class="built_in">console</span>.log(oproxy1[a]);
}
<span class="comment">// 张三</span>
<span class="comment">// 59</span>

<span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) {
  <span class="built_in">console</span>.log(oproxy2[b]);
}
<span class="comment">// 李四</span>
<span class="comment">// 99</span>
</code></pre>
<p>上面代码中，<code>has</code>拦截只对<code>in</code>循环生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被排除在<code>for...in</code>循环之外。</p>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  construct (target, args, newTarget) {
    <span class="keyword">return</span> <span class="keyword">new</span> target(...args);
  }
};
</code></pre>
<p><code>construct</code>方法可以接受两个参数。</p>
<ul>
<li><code>target</code>: 目标对象</li>
<li><code>args</code>：构建函数的参数对象</li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{}, {
  <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));
    <span class="keyword">return</span> { <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> };
  }
});

(<span class="keyword">new</span> p(<span class="number">1</span>)).value
<span class="comment">// "called: 1"</span>
<span class="comment">// 10</span>
</code></pre>
<p><code>construct</code>方法返回的必须是一个对象，否则会报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{}, {
  <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList</span>) </span>{
    <span class="keyword">return</span> <span class="number">1</span>;
  }
});

<span class="keyword">new</span> p() <span class="comment">// 报错</span>
</code></pre>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  deleteProperty (target, key) {
    invariant(key, <span class="string">'delete'</span>);
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
<span class="function"><span class="keyword">function</span> <span class="title">invariant</span> (<span class="params">key, action</span>) </span>{
  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">${action}</span> private "<span class="subst">${key}</span>" property`</span>);
  }
}

<span class="keyword">var</span> target = { <span class="attr">_prop</span>: <span class="string">'foo'</span> };
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
<span class="keyword">delete</span> proxy._prop
<span class="comment">// Error: Invalid attempt to delete private "_prop" property</span>
</code></pre>
<p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty</code>方法拦截了<code>Object.defineProperty</code>操作。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  defineProperty (target, key, descriptor) {
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
};
<span class="keyword">var</span> target = {};
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
proxy.foo = <span class="string">'bar'</span>
<span class="comment">// TypeError: proxy defineProperty handler returned false for property '"foo"'</span>
</code></pre>
<p>上面代码中，<code>defineProperty</code>方法返回<code>false</code>，导致添加新属性会抛出错误。</p>
<p>注意，如果目标对象不可扩展（extensible），则<code>defineProperty</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty</code>方法不得改变这两个设置。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor</code>，返回一个属性描述对象或者<code>undefined</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  getOwnPropertyDescriptor (target, key) {
    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) {
      <span class="keyword">return</span>;
    }
    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);
  }
};
<span class="keyword">var</span> target = { <span class="attr">_foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="string">'tar'</span> };
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>)
<span class="comment">// undefined</span>
<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>)
<span class="comment">// undefined</span>
<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>)
<span class="comment">// { value: 'tar', writable: true, enumerable: true, configurable: true }</span>
</code></pre>
<p>上面代码中，<code>handler.getOwnPropertyDescriptor</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf</code>方法主要用来拦截<code>Object.getPrototypeOf()</code>运算符，以及其他一些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code>运算符</li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> proto = {};
<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  getPrototypeOf(target) {
    <span class="keyword">return</span> proto;
  }
});
<span class="built_in">Object</span>.getPrototypeOf(p) === proto <span class="comment">// true</span>
</code></pre>
<p>上面代码中，<code>getPrototypeOf</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>
<p>注意，<code>getPrototypeOf</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（extensible）， <code>getPrototypeOf</code>方法必须返回目标对象的原型对象。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible</code>方法拦截<code>Object.isExtensible</code>操作。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">isExtensible</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"called"</span>);
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
});

<span class="built_in">Object</span>.isExtensible(p)
<span class="comment">// "called"</span>
<span class="comment">// true</span>
</code></pre>
<p>上面代码设置了<code>isExtensible</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>
<pre><code class="javascript"><span class="built_in">Object</span>.isExtensible(proxy) === <span class="built_in">Object</span>.isExtensible(target)
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">isExtensible</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
});

<span class="built_in">Object</span>.isExtensible(p) <span class="comment">// 报错</span>
</code></pre>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys</code>方法用来拦截以下操作。</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
</ul>
<p>下面是拦截<code>Object.keys()</code>的例子。</p>
<pre><code class="javascript"><span class="keyword">let</span> target = {
  <span class="attr">a</span>: <span class="number">1</span>,
  <span class="attr">b</span>: <span class="number">2</span>,
  <span class="attr">c</span>: <span class="number">3</span>
};

<span class="keyword">let</span> handler = {
  ownKeys(target) {
    <span class="keyword">return</span> [<span class="string">'a'</span>];
  }
};

<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

<span class="built_in">Object</span>.keys(proxy)
<span class="comment">// [ 'a' ]</span>
</code></pre>
<p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<pre><code class="javascript"><span class="keyword">let</span> target = {
  <span class="attr">_bar</span>: <span class="string">'foo'</span>,
  <span class="attr">_prop</span>: <span class="string">'bar'</span>,
  <span class="attr">prop</span>: <span class="string">'baz'</span>
};

<span class="keyword">let</span> handler = {
  ownKeys (target) {
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target).filter(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">'_'</span>);
  }
};

<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(proxy)) {
  <span class="built_in">console</span>.log(target[key]);
}
<span class="comment">// "baz"</span>
</code></pre>
<p>注意，使用<code>Object.keys</code>方法时，有三类属性会被<code>ownKeys</code>方法自动过滤，不会返回。</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为 Symbol 值</li>
<li>不可遍历（<code>enumerable</code>）的属性</li>
</ul>
<pre><code class="javascript"><span class="keyword">let</span> target = {
  <span class="attr">a</span>: <span class="number">1</span>,
  <span class="attr">b</span>: <span class="number">2</span>,
  <span class="attr">c</span>: <span class="number">3</span>,
  [<span class="built_in">Symbol</span>.for(<span class="string">'secret'</span>)]: <span class="string">'4'</span>,
};

<span class="built_in">Object</span>.defineProperty(target, <span class="string">'key'</span>, {
  <span class="attr">enumerable</span>: <span class="literal">false</span>,
  <span class="attr">configurable</span>: <span class="literal">true</span>,
  <span class="attr">writable</span>: <span class="literal">true</span>,
  <span class="attr">value</span>: <span class="string">'static'</span>
});

<span class="keyword">let</span> handler = {
  ownKeys(target) {
    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="built_in">Symbol</span>.for(<span class="string">'secret'</span>), <span class="string">'key'</span>];
  }
};

<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

<span class="built_in">Object</span>.keys(proxy)
<span class="comment">// ['a']</span>
</code></pre>
<p>上面代码中，<code>ownKeys</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
<p><code>ownKeys</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];
  }
});

<span class="built_in">Object</span>.getOwnPropertyNames(p)
<span class="comment">// [ 'a', 'b', 'c' ]</span>
</code></pre>
<p><code>ownKeys</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = {};

<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {
  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, {}, []];
  }
});

<span class="built_in">Object</span>.getOwnPropertyNames(p)
<span class="comment">// Uncaught TypeError: 123 is not a valid property name</span>
</code></pre>
<p>上面代码中，<code>ownKeys</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>
<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys</code>方法返回，否则报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = {};
<span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, {
  <span class="attr">configurable</span>: <span class="literal">false</span>,
  <span class="attr">enumerable</span>: <span class="literal">true</span>,
  <span class="attr">value</span>: <span class="number">10</span> }
);

<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {
  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="keyword">return</span> [<span class="string">'b'</span>];
  }
});

<span class="built_in">Object</span>.getOwnPropertyNames(p)
<span class="comment">// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'</span>
</code></pre>
<p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>
<p>另外，如果目标对象是不可扩展的（non-extensition），这时<code>ownKeys</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> obj = {
  <span class="attr">a</span>: <span class="number">1</span>
};

<span class="built_in">Object</span>.preventExtensions(obj);

<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, {
  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>];
  }
});

<span class="built_in">Object</span>.getOwnPropertyNames(p)
<span class="comment">// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible</span>
</code></pre>
<p>上面代码中，<code>Obj</code>对象是不可扩展的，这时<code>ownKeys</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">preventExtensions</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
});

<span class="built_in">Object</span>.preventExtensions(p) <span class="comment">// 报错</span>
</code></pre>
<p>上面代码中，<code>proxy.preventExtensions</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>
<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions</code>方法里面，调用一次<code>Object.preventExtensions</code>。</p>
<pre><code class="javascript"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
  <span class="attr">preventExtensions</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'called'</span>);
    <span class="built_in">Object</span>.preventExtensions(target);
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
});

<span class="built_in">Object</span>.preventExtensions(p)
<span class="comment">// "called"</span>
<span class="comment">// true</span>
</code></pre>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf</code>方法主要用来拦截<code>Object.setPrototypeOf</code>方法。</p>
<p>下面是一个例子。</p>
<pre><code class="javascript"><span class="keyword">var</span> handler = {
  setPrototypeOf (target, proto) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);
  }
};
<span class="keyword">var</span> proto = {};
<span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{};
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);
proxy.setPrototypeOf(proxy, proto);
<span class="comment">// Error: Changing the prototype is forbidden</span>
</code></pre>
<p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），<code>setPrototypeOf</code>方法不得改变目标对象的原型。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable</code>方法返回一个可取消的 Proxy 实例。</p>
<pre><code class="javascript"><span class="keyword">let</span> target = {};
<span class="keyword">let</span> handler = {};

<span class="keyword">let</span> {proxy, revoke} = <span class="built_in">Proxy</span>.revocable(target, handler);

proxy.foo = <span class="number">123</span>;
proxy.foo <span class="comment">// 123</span>

revoke();
proxy.foo <span class="comment">// TypeError: Revoked</span>
</code></pre>
<p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<pre><code class="javascript"><span class="keyword">const</span> target = {
  <span class="attr">m</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);
  }
};
<span class="keyword">const</span> handler = {};

<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

target.m() <span class="comment">// false</span>
proxy.m()  <span class="comment">// true</span>
</code></pre>
<p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>
<pre><code class="javascript"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();

<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{
  <span class="keyword">constructor</span>(name) {
    _name.set(<span class="keyword">this</span>, name);
  }
  get name() {
    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);
  }
}

<span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);
jane.name <span class="comment">// 'Jane'</span>

<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, {});
proxy.name <span class="comment">// undefined</span>
</code></pre>
<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<pre><code class="javascript"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();
<span class="keyword">const</span> handler = {};
<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

proxy.getDate();
<span class="comment">// TypeError: this is not a Date object.</span>
</code></pre>
<p>上面代码中，<code>getDate</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<pre><code class="javascript"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);
<span class="keyword">const</span> handler = {
  get(target, prop) {
    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) {
      <span class="keyword">return</span> target.getDate.bind(target);
    }
    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);
  }
};
<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);

proxy.getDate() <span class="comment">// 1</span>
</code></pre>
<h2 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<pre><code class="javascript"><span class="keyword">const</span> service = createWebService(<span class="string">'http://example.com/data'</span>);

service.employees().then(<span class="function"><span class="params">json</span> =&gt;</span> {
  <span class="keyword">const</span> employees = <span class="built_in">JSON</span>.parse(json);
  <span class="comment">// ···</span>
});
</code></pre>
<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createWebService</span>(<span class="params">baseUrl</span>) </span>{
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {
    get(target, propKey, receiver) {
      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> httpGet(baseUrl+<span class="string">'/'</span> + propKey);
    }
  });
}
</code></pre>
<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Proxy&lt;br&gt;date: 2017-01-09 10:40:19&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ECMAScript6
- JavaScript
- JS
- ES6
- Proxy
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h
    
    </summary>
    
    
  </entry>
  
</feed>
